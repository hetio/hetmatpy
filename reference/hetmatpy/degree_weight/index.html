
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.4, mkdocs-material-7.3.0">
    
    
      
        <title>Degree Weight - hetmatpy</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.8b42a75e.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.3f5d1f46.min.css">
        
          
          
          <meta name="theme-color" content="#4cae4f">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="green" data-md-color-accent="lightgreen">
  
    
    <script>function __prefix(e){return new URL("../../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#module-hetmatpydegree_weight" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="hetmatpy" class="md-header__button md-logo" aria-label="hetmatpy" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            hetmatpy
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Degree Weight
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/hetio/hetmatpy/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    hetmatpy
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="hetmatpy" class="md-nav__button md-logo" aria-label="hetmatpy" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    hetmatpy
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/hetio/hetmatpy/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    hetmatpy
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../LICENSE/" class="md-nav__link">
        License
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          Reference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Reference" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_1" type="checkbox" id="__nav_3_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_3_1">
          Hetmatpy
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Hetmatpy" data-md-level="2">
        <label class="md-nav__title" for="__nav_3_1">
          <span class="md-nav__icon md-icon"></span>
          Hetmatpy
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../degree_group/" class="md-nav__link">
        Degree Group
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Degree Weight
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Degree Weight
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#categorize" class="md-nav__link">
    categorize
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#default_dwwc_method" class="md-nav__link">
    default_dwwc_method
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwpc" class="md-nav__link">
    dwpc
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc" class="md-nav__link">
    dwwc
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc_chain" class="md-nav__link">
    dwwc_chain
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc_recursive" class="md-nav__link">
    dwwc_recursive
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc_sequential" class="md-nav__link">
    dwwc_sequential
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_all_segments" class="md-nav__link">
    get_all_segments
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_segments" class="md-nav__link">
    get_segments
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#order_segments" class="md-nav__link">
    order_segments
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_diag" class="md-nav__link">
    remove_diag
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../diffusion/" class="md-nav__link">
        Diffusion
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../matrix/" class="md-nav__link">
        Matrix
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../pipeline/" class="md-nav__link">
        Pipeline
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../testing/" class="md-nav__link">
        Testing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xarray/" class="md-nav__link">
        Xarray
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_1_9" type="checkbox" id="__nav_3_1_9" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3_1_9">
          Hetmat
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Hetmat" data-md-level="3">
        <label class="md-nav__title" for="__nav_3_1_9">
          <span class="md-nav__icon md-icon"></span>
          Hetmat
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../hetmat/archive/" class="md-nav__link">
        Archive
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../hetmat/caching/" class="md-nav__link">
        Caching
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../hetmat/" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#categorize" class="md-nav__link">
    categorize
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#default_dwwc_method" class="md-nav__link">
    default_dwwc_method
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwpc" class="md-nav__link">
    dwpc
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc" class="md-nav__link">
    dwwc
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc_chain" class="md-nav__link">
    dwwc_chain
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc_recursive" class="md-nav__link">
    dwwc_recursive
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dwwc_sequential" class="md-nav__link">
    dwwc_sequential
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_all_segments" class="md-nav__link">
    get_all_segments
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_segments" class="md-nav__link">
    get_segments
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#order_segments" class="md-nav__link">
    order_segments
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_diag" class="md-nav__link">
    remove_diag
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/hetio/hetmatpy/edit/main/reference/hetmatpy/degree_weight.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="module-hetmatpydegree_weight">Module hetmatpy.degree_weight</h1>
<p>None</p>
<p>None</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">collections</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">functools</span>

<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">hetnetpy.matrix</span> <span class="kn">import</span> <span class="n">sparsify_or_densify</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>

<span class="kn">import</span> <span class="nn">hetmatpy.hetmat</span>

<span class="kn">import</span> <span class="nn">hetmatpy.matrix</span>

<span class="kn">from</span> <span class="nn">hetmatpy.hetmat.caching</span> <span class="kn">import</span> <span class="n">path_count_cache</span>

<span class="k">def</span> <span class="nf">_category_to_function</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">dwwc_method</span><span class="p">):</span>

    <span class="n">function_dictionary</span> <span class="o">=</span> <span class="p">{</span>

        <span class="s2">&quot;no_repeats&quot;</span><span class="p">:</span> <span class="n">dwwc_method</span><span class="p">,</span>

        <span class="s2">&quot;disjoint&quot;</span><span class="p">:</span> <span class="n">_dwpc_disjoint</span><span class="p">,</span>

        <span class="s2">&quot;disjoint_groups&quot;</span><span class="p">:</span> <span class="n">_dwpc_disjoint</span><span class="p">,</span>

        <span class="s2">&quot;short_repeat&quot;</span><span class="p">:</span> <span class="n">_dwpc_short_repeat</span><span class="p">,</span>

        <span class="s2">&quot;four_repeat&quot;</span><span class="p">:</span> <span class="n">_dwpc_baba</span><span class="p">,</span>

        <span class="s2">&quot;long_repeat&quot;</span><span class="p">:</span> <span class="n">_dwpc_general_case</span><span class="p">,</span>

        <span class="s2">&quot;BAAB&quot;</span><span class="p">:</span> <span class="n">_dwpc_baab</span><span class="p">,</span>

        <span class="s2">&quot;BABA&quot;</span><span class="p">:</span> <span class="n">_dwpc_baba</span><span class="p">,</span>

        <span class="s2">&quot;repeat_around&quot;</span><span class="p">:</span> <span class="n">_dwpc_repeat_around</span><span class="p">,</span>

        <span class="s2">&quot;interior_complete_group&quot;</span><span class="p">:</span> <span class="n">_dwpc_baba</span><span class="p">,</span>

        <span class="s2">&quot;other&quot;</span><span class="p">:</span> <span class="n">_dwpc_general_case</span><span class="p">,</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="n">function_dictionary</span><span class="p">[</span><span class="n">category</span><span class="p">]</span>

<span class="nd">@path_count_cache</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s2">&quot;dwpc&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dwpc</span><span class="p">(</span>

    <span class="n">graph</span><span class="p">,</span>

    <span class="n">metapath</span><span class="p">,</span>

    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>

    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

    <span class="n">approx_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>

    <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>

    <span class="n">dwwc_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>

<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    A unified function to compute the degree-weighted path count.</span>

<span class="sd">    This function will call get_segments, then the appropriate</span>

<span class="sd">    specialized (or generalized) DWPC function.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    damping : float</span>

<span class="sd">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="sd">        sets the density threshold above which a sparse matrix will be</span>

<span class="sd">        converted to a dense automatically.</span>

<span class="sd">    approx_ok : bool</span>

<span class="sd">        if True, uses an approximation to DWPC. If False, dwpc will call</span>

<span class="sd">        _dwpc_general_case and give a warning on metapaths which are</span>

<span class="sd">        categorized &#39;other&#39; and &#39;long_repeat&#39;..</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">        numpy.float32 or numpy.float64. At present, numpy.float16 fails when</span>

<span class="sd">        using sparse matrices, due to a bug in scipy.sparse</span>

<span class="sd">    dwwc_method : function</span>

<span class="sd">        dwwc method to use for computing DWWCs. If set to None, use</span>

<span class="sd">        module-level default (default_dwwc_method).</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    numpy.ndarray</span>

<span class="sd">        row labels</span>

<span class="sd">    numpy.ndarray</span>

<span class="sd">        column labels</span>

<span class="sd">    numpy.ndarray or scipy.sparse.csc_matrix</span>

<span class="sd">        the DWPC matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">category</span> <span class="o">=</span> <span class="n">categorize</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">dwpc_function</span> <span class="o">=</span> <span class="n">_category_to_function</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">dwwc_method</span><span class="o">=</span><span class="n">dwwc_method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;long_repeat&quot;</span><span class="p">,</span> <span class="s2">&quot;other&quot;</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">approx_ok</span><span class="p">:</span>

            <span class="n">dwpc_function</span> <span class="o">=</span> <span class="n">_dwpc_approx</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>

                <span class="sa">f</span><span class="s2">&quot;Metapath </span><span class="si">{</span><span class="n">metapath</span><span class="si">}</span><span class="s2"> will use _dwpc_general_case, &quot;</span>

                <span class="s2">&quot;which can require very long computations.&quot;</span>

            <span class="p">)</span>

    <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_function</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="nd">@path_count_cache</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s2">&quot;dwwc&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dwwc</span><span class="p">(</span>

    <span class="n">graph</span><span class="p">,</span>

    <span class="n">metapath</span><span class="p">,</span>

    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>

    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

    <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>

    <span class="n">dwwc_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>

<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Compute the degree-weighted walk count (DWWC) in which nodes can be</span>

<span class="sd">    repeated within a path.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    damping : float</span>

<span class="sd">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="sd">        sets the density threshold at which a sparse matrix will be</span>

<span class="sd">        converted to a dense automatically.</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">    dwwc_method : function</span>

<span class="sd">        dwwc method to use for computing DWWCs. If set to None, use</span>

<span class="sd">        module-level default (default_dwwc_method).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dwwc_method</span><span class="p">(</span>

        <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>

        <span class="n">metapath</span><span class="o">=</span><span class="n">metapath</span><span class="p">,</span>

        <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

        <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

        <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

    <span class="p">)</span>

<span class="k">def</span> <span class="nf">dwwc_sequential</span><span class="p">(</span>

    <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>

<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Compute the degree-weighted walk count (DWWC) in which nodes can be</span>

<span class="sd">    repeated within a path.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    damping : float</span>

<span class="sd">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="sd">        sets the density threshold at which a sparse matrix will be</span>

<span class="sd">        converted to a dense automatically.</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">row_names</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">metaedge</span> <span class="ow">in</span> <span class="n">metapath</span><span class="p">:</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span> <span class="n">metaedge</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span>

        <span class="p">)</span>

        <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dwwc_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">row_names</span> <span class="o">=</span> <span class="n">rows</span>

            <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">adj_mat</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">dwwc_matrix</span> <span class="o">@</span> <span class="n">adj_mat</span>

            <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwwc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwwc_matrix</span>

<span class="k">def</span> <span class="nf">dwwc_recursive</span><span class="p">(</span>

    <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>

<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Recursive DWWC implementation to take better advantage of caching.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span>

    <span class="p">)</span>

    <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwwc_next</span> <span class="o">=</span> <span class="n">dwwc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span>

            <span class="n">metapath</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>

            <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

            <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

            <span class="n">dwwc_method</span><span class="o">=</span><span class="n">dwwc_recursive</span><span class="p">,</span>

        <span class="p">)</span>

        <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">adj_mat</span> <span class="o">@</span> <span class="n">dwwc_next</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">adj_mat</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwwc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwwc_matrix</span>

<span class="k">def</span> <span class="nf">_multi_dot</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Perform matrix multiplication with the given order. Modified from</span>

<span class="sd">    numpy.linalg.linalg._multi_dot (https://git.io/vh31f) which is released</span>

<span class="sd">    under a 3-Clause BSD License (https://git.io/vhCDC).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span>

        <span class="p">)</span>

        <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">adj_mat</span>

    <span class="k">return</span> <span class="n">_multi_dot</span><span class="p">(</span>

        <span class="n">metapath</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">graph</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span>

    <span class="p">)</span> <span class="o">@</span> <span class="n">_multi_dot</span><span class="p">(</span>

        <span class="n">metapath</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span>

    <span class="p">)</span>

<span class="k">def</span> <span class="nf">_dimensions_to_ordering</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>

    <span class="c1"># Find optimal matrix chain ordering. See https://git.io/vh38o</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

    <span class="n">ordering</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">l_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">l_</span><span class="p">):</span>

            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">l_</span>

            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">inf</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>

                <span class="n">q</span> <span class="o">=</span> <span class="p">(</span>

                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>

                    <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                    <span class="o">+</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="p">)</span>

                <span class="k">if</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>

                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>

                    <span class="n">ordering</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

    <span class="k">return</span> <span class="n">ordering</span>

<span class="k">def</span> <span class="nf">dwwc_chain</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Uses optimal matrix chain multiplication as in numpy.multi_dot, but allows</span>

<span class="sd">    for sparse matrices. Uses ordering modified from numpy.linalg.linalg._multi_dot</span>

<span class="sd">    (https://git.io/vh31f) which is released under a 3-Clause BSD License</span>

<span class="sd">    (https://git.io/vhCDC).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metapath</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="o">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">array_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">count_nodes</span><span class="p">(</span><span class="n">mn</span><span class="p">)</span> <span class="k">for</span> <span class="n">mn</span> <span class="ow">in</span> <span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()]</span>

    <span class="n">row_ids</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">get_node_identifiers</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="o">.</span><span class="kp">source</span><span class="p">())</span>

    <span class="n">columns_ids</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">get_node_identifiers</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="o">.</span><span class="n">target</span><span class="p">())</span>

    <span class="n">ordering</span> <span class="o">=</span> <span class="n">_dimensions_to_ordering</span><span class="p">(</span><span class="n">array_dims</span><span class="p">)</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">_multi_dot</span><span class="p">(</span>

        <span class="n">metapath</span><span class="p">,</span> <span class="n">ordering</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span>

    <span class="p">)</span>

    <span class="n">dwwc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwwc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">columns_ids</span><span class="p">,</span> <span class="n">dwwc_matrix</span>

<span class="k">def</span> <span class="nf">categorize</span><span class="p">(</span><span class="n">metapath</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Returns the classification of a given metapath as one of</span>

<span class="sd">    a set of metapath types which we approach differently.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    classification : string</span>

<span class="sd">        One of [&#39;no_repeats&#39;, &#39;disjoint&#39;, &#39;short_repeat&#39;,</span>

<span class="sd">                &#39;long_repeat&#39;, &#39;BAAB&#39;, &#39;BABA&#39;, &#39;repeat_around&#39;,</span>

<span class="sd">                 &#39;interior_complete_group&#39;, &#39;disjoint_groups&#39;, &#39;other&#39;]</span>

<span class="sd">    Examples</span>

<span class="sd">    --------</span>

<span class="sd">    GbCtDlA -&gt; &#39;no_repeats&#39;</span>

<span class="sd">    GiGiG   -&gt; &#39;short_repeat&#39;</span>

<span class="sd">    GiGiGcG -&gt; &#39;four_repeat&#39;</span>

<span class="sd">    GiGcGiGiG -&gt; &#39;long_repeat&#39;</span>

<span class="sd">    GiGbCrC -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GbCbGbC -&gt; &#39;BABA&#39;</span>

<span class="sd">    GbCrCbG -&gt; &#39;BAAB&#39;</span>

<span class="sd">    DaGiGbCrC -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GiGaDpCrC -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GiGbCrCpDrD -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GbCpDaGbCpD -&gt; &#39;other&#39;</span>

<span class="sd">    GbCrCrCrCrCbG -&gt; &#39;other&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metanodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">())</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

    <span class="n">repeated</span> <span class="o">=</span> <span class="p">{</span><span class="n">metanode</span> <span class="k">for</span> <span class="n">metanode</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">freq</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">repeated</span><span class="p">:</span>

        <span class="k">return</span> <span class="s2">&quot;no_repeats&quot;</span>

    <span class="n">repeats_only</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">metanodes</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">repeated</span><span class="p">]</span>

    <span class="c1"># Group neighbors if they are the same</span>

    <span class="n">grouped</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)]</span>

    <span class="c1"># Handle multiple disjoint repeats, any number, ie. AA,BB,CC,DD,...</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">):</span>

        <span class="c1"># Identify if there is only one metanode</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>

                <span class="k">return</span> <span class="s2">&quot;short_repeat&quot;</span>

            <span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>

                <span class="k">return</span> <span class="s2">&quot;four_repeat&quot;</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">return</span> <span class="s2">&quot;long_repeat&quot;</span>

        <span class="k">return</span> <span class="s2">&quot;disjoint&quot;</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>

    <span class="c1"># Categorize the reformatted metapath</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="k">assert</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">return</span> <span class="s2">&quot;BAAB&quot;</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">assert</span> <span class="p">(</span>

                <span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                <span class="ow">and</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

            <span class="p">)</span>

            <span class="k">return</span> <span class="s2">&quot;BABA&quot;</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">grouped</span><span class="p">))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="k">return</span> <span class="s2">&quot;BAAB&quot;</span>

    <span class="k">elif</span> <span class="n">repeats_only</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>

        <span class="k">return</span> <span class="s2">&quot;BAAB&quot;</span>

    <span class="c1"># 6 node paths with 3x2 repeats</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">repeats_only</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="k">return</span> <span class="s2">&quot;repeat_around&quot;</span>

        <span class="c1"># AABCCB or AABCBC</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

            <span class="k">return</span> <span class="s2">&quot;disjoint_groups&quot;</span>

        <span class="c1"># ABA CC B</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">return</span> <span class="s2">&quot;interior_complete_group&quot;</span>

        <span class="c1"># most complicated len 6</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="s2">&quot;other&quot;</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Multi-repeats that aren&#39;t disjoint, eg. ABCBAC</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>

            <span class="n">logging</span><span class="o">.</span><span class="kp">info</span><span class="p">(</span>

                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">metapath</span><span class="si">}</span><span class="s2">: Only two overlapping repeats currently supported&quot;</span>

            <span class="p">)</span>

            <span class="k">return</span> <span class="s2">&quot;other&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>

            <span class="n">logging</span><span class="o">.</span><span class="kp">info</span><span class="p">(</span>

                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">metapath</span><span class="si">}</span><span class="s2">: Complex metapaths of length &gt; 4 are not yet &quot;</span> <span class="sa">f</span><span class="s2">&quot;supported&quot;</span>

            <span class="p">)</span>

            <span class="k">return</span> <span class="s2">&quot;other&quot;</span>

        <span class="k">assert</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Split a metapath into segments of recognized groups and non-repeated</span>

<span class="sd">    nodes. Groups include BAAB, BABA, disjoint short- and long-repeats.</span>

<span class="sd">    Returns an error for categorization &#39;other&#39;.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="sd">    metapath : hetnetpy.hetnet.Metapath</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    list</span>

<span class="sd">        list of metapaths. If the metapath is not segmentable or is already</span>

<span class="sd">        fully simplified (eg. GiGaDaG), then the list will have only one</span>

<span class="sd">        element.</span>

<span class="sd">    Examples</span>

<span class="sd">    --------</span>

<span class="sd">    &#39;CbGaDaGaD&#39; -&gt; [&#39;CbG&#39;, &#39;GaD&#39;, &#39;GaG&#39;, &#39;GaD&#39;]</span>

<span class="sd">    &#39;GbCpDaGaD&#39; -&gt; [&#39;GbCpD&#39;, &#39;DaG&#39;, &#39;GaD&#39;]</span>

<span class="sd">    &#39;CrCbGiGaDrD&#39; -&gt; [&#39;CrC&#39;, &#39;CbG&#39;, &#39;GiG&#39;, &#39;GaD&#39;, &#39;DrD&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_head_tail</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="kp">indices</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Makes sure that all metanodes are included in segments.</span>

<span class="sd">        Ensures that the first segment goes all the way back to the</span>

<span class="sd">        first metanode. Similarly, makes sure that the last segment</span>

<span class="sd">        includes all metanodes up to the last one.&quot;&quot;&quot;</span>

        <span class="c1"># handle non-duplicated on the front</span>

        <span class="k">if</span> <span class="kp">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="kp">indices</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kp">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span> <span class="o">+</span> <span class="kp">indices</span>

        <span class="c1"># handle non-duplicated on the end</span>

        <span class="k">if</span> <span class="kp">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">):</span>

            <span class="kp">indices</span> <span class="o">=</span> <span class="kp">indices</span> <span class="o">+</span> <span class="p">[(</span><span class="kp">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">))]</span>

        <span class="k">return</span> <span class="kp">indices</span>

    <span class="n">metapath</span> <span class="o">=</span> <span class="n">metagraph</span><span class="o">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">category</span> <span class="o">=</span> <span class="n">categorize</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">metanodes</span> <span class="o">=</span> <span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

    <span class="n">repeated</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">freq</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">category</span> <span class="o">==</span> <span class="s2">&quot;no_repeats&quot;</span><span class="p">:</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">metapath</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">category</span> <span class="o">==</span> <span class="s2">&quot;repeat_around&quot;</span><span class="p">:</span>

        <span class="c1"># Note this is hard-coded and will need to be updated for various</span>

        <span class="c1"># metapath lengths</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

    <span class="k">elif</span> <span class="n">category</span> <span class="o">==</span> <span class="s2">&quot;disjoint_groups&quot;</span><span class="p">:</span>

        <span class="c1"># CCBABA or CCBAAB or BABACC or BAABCC -&gt; [CC, BABA], etc.</span>

        <span class="n">metanodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">())</span>

        <span class="n">grouped</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)]</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="p">(</span>

            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span>

            <span class="k">else</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">category</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;disjoint&quot;</span><span class="p">,</span> <span class="s2">&quot;short_repeat&quot;</span><span class="p">,</span> <span class="s2">&quot;long_repeat&quot;</span><span class="p">):</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>

            <span class="p">[</span><span class="n">metanodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">-</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">metanodes</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">repeated</span>

        <span class="p">)</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="n">add_head_tail</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="kp">indices</span><span class="p">)</span>

        <span class="c1"># handle middle cases with non-repeated nodes between disjoint regions</span>

        <span class="c1"># Eg. [[0,2], [3,4]] -&gt; [[0,2],[2,3],[3,4]]</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="kp">indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>

            <span class="n">inds</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="kp">indices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>

                <span class="n">inds</span><span class="o">.</span><span class="kp">append</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="kp">indices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="n">inds</span> <span class="o">+</span> <span class="p">[</span><span class="kp">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">elif</span> <span class="n">category</span> <span class="o">==</span> <span class="s2">&quot;four_repeat&quot;</span><span class="p">:</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

        <span class="n">repeat_indices</span> <span class="o">=</span> <span class="p">[</span>

            <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">metanode</span><span class="p">]</span> <span class="k">for</span> <span class="n">metanode</span> <span class="ow">in</span> <span class="n">nodes</span>

        <span class="p">]</span>

        <span class="n">repeat_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">repeat_indices</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">simple_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">repeat_indices</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>

        <span class="n">seconds</span> <span class="o">=</span> <span class="n">simple_repeats</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">simple_repeats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">simple_repeats</span><span class="p">,</span> <span class="n">seconds</span><span class="p">))</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="n">add_head_tail</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="kp">indices</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">category</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;BAAB&quot;</span><span class="p">,</span> <span class="s2">&quot;BABA&quot;</span><span class="p">,</span> <span class="s2">&quot;other&quot;</span><span class="p">,</span> <span class="s2">&quot;interior_complete_group&quot;</span><span class="p">):</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

        <span class="n">repeat_indices</span> <span class="o">=</span> <span class="p">[</span>

            <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">metanode</span><span class="p">]</span> <span class="k">for</span> <span class="n">metanode</span> <span class="ow">in</span> <span class="n">nodes</span>

        <span class="p">]</span>

        <span class="n">repeat_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">repeat_indices</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">simple_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">repeat_indices</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">repeat_indices</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

                <span class="n">inds</span> <span class="o">+=</span> <span class="n">i</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>

                <span class="n">inds</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">inds</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">simple_repeats</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">simple_repeats</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>

                        <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">i</span>

                    <span class="p">):</span>

                        <span class="n">inds</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>

        <span class="n">seconds</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">seconds</span><span class="p">))</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="kp">indices</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">]</span>

        <span class="kp">indices</span> <span class="o">=</span> <span class="n">add_head_tail</span><span class="p">(</span><span class="n">metapath</span><span class="p">,</span> <span class="kp">indices</span><span class="p">)</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">metapath</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="kp">indices</span><span class="p">]</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">segments</span> <span class="k">if</span> <span class="n">i</span><span class="p">]</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">metagraph</span><span class="o">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metaedges</span><span class="p">)</span> <span class="k">for</span> <span class="n">metaedges</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]</span>

    <span class="c1"># eg: B CC ABA</span>

    <span class="k">if</span> <span class="n">category</span> <span class="o">==</span> <span class="s2">&quot;interior_complete_group&quot;</span><span class="p">:</span>

        <span class="n">segs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>

            <span class="k">if</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

                <span class="n">edges</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">edges</span> <span class="o">+</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span> <span class="o">+</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span>

                <span class="n">segs</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">metagraph</span><span class="o">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

                <span class="k">pass</span>

            <span class="k">elif</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

                <span class="k">pass</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">segs</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">segs</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">segments</span> <span class="o">=</span> <span class="n">segs</span>

    <span class="k">return</span> <span class="n">segments</span>

<span class="k">def</span> <span class="nf">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Return all subsegments of a given metapath, including those segments that</span>

<span class="sd">    appear only after early splits.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    list</span>

<span class="sd">    Example</span>

<span class="sd">    -------</span>

<span class="sd">    &gt;&gt;&gt; get_all_segments(metagraph, CrCbGaDrDaG)</span>

<span class="sd">    [CrC, CbG, GaDrDaG, GaD, DrD, DaG]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metapath</span> <span class="o">=</span> <span class="n">metagraph</span><span class="o">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">metapath</span><span class="p">]</span>

    <span class="n">all_subsegments</span> <span class="o">=</span> <span class="p">[</span><span class="n">metapath</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>

        <span class="n">subsegments</span> <span class="o">=</span> <span class="n">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">segment</span><span class="p">)</span>

        <span class="n">next_split</span> <span class="o">=</span> <span class="n">subsegments</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsegments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="n">all_subsegments</span> <span class="o">=</span> <span class="n">all_subsegments</span> <span class="o">+</span> <span class="p">[</span><span class="n">segment</span><span class="p">]</span> <span class="o">+</span> <span class="n">next_split</span>

    <span class="k">return</span> <span class="n">all_subsegments</span>

<span class="k">def</span> <span class="nf">order_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapaths</span><span class="p">,</span> <span class="n">store_inverses</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Gives the frequencies of metapath segments that occur when computing DWPC.</span>

<span class="sd">    In DWPC computation, metapaths are split a number of times for simpler computation.</span>

<span class="sd">    This function finds the frequencies that segments would be used when computing</span>

<span class="sd">    DWPC for all given metapaths. For the targeted caching of the most frequently</span>

<span class="sd">    used segments.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="sd">    metapaths : list</span>

<span class="sd">        list of hetnetpy.hetnet.MetaPath objects</span>

<span class="sd">    store_inverses : bool</span>

<span class="sd">        Whether or not to include both forward and backward directions of segments.</span>

<span class="sd">        For example, if False: [CbG, GbC] -&gt; [CbG, CbG], else no change.</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    collections.Counter</span>

<span class="sd">        Number of times each metapath segment appears when getting all segments.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">all_segments</span> <span class="o">=</span> <span class="p">[</span>

        <span class="n">segment</span>

        <span class="k">for</span> <span class="n">metapath</span> <span class="ow">in</span> <span class="n">metapaths</span>

        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">store_inverses</span><span class="p">:</span>

        <span class="c1"># Change all instances of inverted segments to the same direction, using a first-seen ordering</span>

        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">aligned_segments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">all_segments</span><span class="p">:</span>

            <span class="kp">add</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">inverse</span> <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">inverse</span> <span class="ow">in</span> <span class="n">seen</span> <span class="k">else</span> <span class="n">segment</span>

            <span class="n">aligned_segments</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="kp">add</span><span class="p">)</span>

            <span class="n">seen</span><span class="o">.</span><span class="kp">add</span><span class="p">(</span><span class="kp">add</span><span class="p">)</span>

        <span class="n">all_segments</span> <span class="o">=</span> <span class="n">aligned_segments</span>

    <span class="n">segment_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">all_segments</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">segment_counts</span>

<span class="k">def</span> <span class="nf">remove_diag</span><span class="p">(</span><span class="kp">mat</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Set the main diagonal of a square matrix to zeros.&quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="kp">mat</span><span class="o">.</span><span class="kp">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kp">mat</span><span class="o">.</span><span class="kp">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># must be square</span>

    <span class="k">if</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="kp">mat</span><span class="p">):</span>

        <span class="k">return</span> <span class="kp">mat</span> <span class="o">-</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="kp">mat</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">(),</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">return</span> <span class="kp">mat</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">diag</span><span class="p">(</span><span class="kp">mat</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">_degree_weight</span><span class="p">(</span><span class="kp">matrix</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Normalize an adjacency matrix by the in and out degree.&quot;&quot;&quot;</span>

    <span class="kp">matrix</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">copy_array</span><span class="p">(</span><span class="kp">matrix</span><span class="p">,</span> <span class="kp">copy</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="kp">matrix</span><span class="o">.</span><span class="kp">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span><span class="o">.</span><span class="kp">flatten</span><span class="p">()</span>

    <span class="n">column_sums</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="kp">matrix</span><span class="o">.</span><span class="kp">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span><span class="o">.</span><span class="kp">flatten</span><span class="p">()</span>

    <span class="kp">matrix</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="kp">matrix</span><span class="p">,</span> <span class="n">row_sums</span><span class="p">,</span> <span class="s2">&quot;rows&quot;</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>

    <span class="kp">matrix</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="kp">matrix</span><span class="p">,</span> <span class="n">column_sums</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>

    <span class="k">return</span> <span class="kp">matrix</span>

<span class="k">def</span> <span class="nf">_dwpc_approx</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Compute an approximation of DWPC. Only removes the diagonal for the first</span>

<span class="sd">    repeated node, and any disjoint repetitions that follow the last occurrence</span>

<span class="sd">    of the first repeating node.</span>

<span class="sd">    Examples</span>

<span class="sd">    --------</span>

<span class="sd">    GiGbCrC -&gt; Identical output to DWPC</span>

<span class="sd">    GiGbCbGiG -&gt; Approximation</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">row_names</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Find the first repeated metanode and where it occurs</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>

    <span class="n">repeated_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]]</span>

    <span class="n">first_repeat</span> <span class="o">=</span> <span class="n">repeated_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">repeated_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">first_repeat</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">repeated_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span>

            <span class="n">metapath</span><span class="p">[</span><span class="n">repeated_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">segment</span><span class="p">],</span>

            <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

            <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

        <span class="p">)</span>

        <span class="k">if</span> <span class="n">row_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">row_names</span> <span class="o">=</span> <span class="n">rows</span>

    <span class="c1"># Add head and tail segments, if applicable</span>

    <span class="k">if</span> <span class="n">repeated_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">row_names</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">head_seg</span> <span class="o">=</span> <span class="n">dwwc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span>

            <span class="n">metapath</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">repeated_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>

            <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

            <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

        <span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">head_seg</span> <span class="o">@</span> <span class="n">dwpc_matrix</span>

    <span class="k">if</span> <span class="n">nodes</span><span class="p">[</span><span class="n">repeated_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">tail_seg</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span>

            <span class="n">metapath</span><span class="p">[</span><span class="n">repeated_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">:],</span>

            <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

            <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

        <span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">tail_seg</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">sparsify_or_densify</span><span class="p">(</span><span class="n">dwpc_matrix</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="k">def</span> <span class="nf">_dwpc_disjoint</span><span class="p">(</span>

    <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>

<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;DWPC for disjoint repeats or disjoint groups&quot;&quot;&quot;</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="n">row_names</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">col_names</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">seg_matrix</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span>

            <span class="n">segment</span><span class="p">,</span>

            <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

            <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

        <span class="p">)</span>

        <span class="k">if</span> <span class="n">row_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">row_names</span> <span class="o">=</span> <span class="n">rows</span>

        <span class="k">if</span> <span class="n">segment</span> <span class="ow">is</span> <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="n">col_names</span> <span class="o">=</span> <span class="n">cols</span>

        <span class="k">if</span> <span class="n">dwpc_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">seg_matrix</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">seg_matrix</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="k">def</span> <span class="nf">_dwpc_repeat_around</span><span class="p">(</span>

    <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>

<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    DWPC for situations in which we have a surrounding repeat like</span>

<span class="sd">    B----B, where the middle group is a more complicated group. The</span>

<span class="sd">    purpose of this function is just as an order-of-operations simplification</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span>

        <span class="n">segments</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>

        <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

        <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

        <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

    <span class="p">)[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj0</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span>

        <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>

        <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

        <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

        <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

    <span class="p">)</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">adj1</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span>

        <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>

        <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

        <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

        <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

    <span class="p">)</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">adj0</span> <span class="o">@</span> <span class="n">mid</span> <span class="o">@</span> <span class="n">adj1</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="k">def</span> <span class="nf">_dwpc_baab</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    A function to handle metapath (segments) of the form BAAB.</span>

<span class="sd">    This function will handle arbitrary lengths of this repeated</span>

<span class="sd">    pattern. For example, ABCCBA, ABCDDCBA, etc. all work with this</span>

<span class="sd">    function. Random non-repeat inserts are supported. The metapath</span>

<span class="sd">    must start and end with a repeated node, though.</span>

<span class="sd">    Covers all variants of symmetrically repeated metanodes with</span>

<span class="sd">    support for random non-repeat metanode inserts at any point.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    damping : float</span>

<span class="sd">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="sd">        sets the density threshold above which a sparse matrix will be</span>

<span class="sd">        converted to a dense automatically.</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">    Examples</span>

<span class="sd">    --------</span>

<span class="sd">    Acceptable metapaths forms include the following:</span>

<span class="sd">    B-A-A-B</span>

<span class="sd">    B-C-A-A-B</span>

<span class="sd">    B-C-A-D-A-E-B</span>

<span class="sd">    B-C-D-E-A-F-A-B</span>

<span class="sd">    C-B-A-A-B-D-E</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Segment the metapath</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="c1"># Start with the middle group (A-A or A-...-A in BAAB)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

            <span class="n">mid_seg</span> <span class="o">=</span> <span class="n">s</span>

            <span class="n">mid_ind</span> <span class="o">=</span> <span class="n">i</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwpc_mid</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">mid_seg</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span>

    <span class="p">)</span>

    <span class="n">dwpc_mid</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_mid</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="c1"># Get two indices for the segments ahead of and behind the middle region</span>

    <span class="n">head_ind</span> <span class="o">=</span> <span class="n">mid_ind</span>

    <span class="n">tail_ind</span> <span class="o">=</span> <span class="n">mid_ind</span>

    <span class="k">while</span> <span class="n">head_ind</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tail_ind</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>

        <span class="n">head_ind</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">tail_ind</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">head</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">head_ind</span><span class="p">]</span> <span class="k">if</span> <span class="n">head_ind</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">tail</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">tail_ind</span><span class="p">]</span> <span class="k">if</span> <span class="n">tail_ind</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Multiply on the head</span>

        <span class="k">if</span> <span class="n">head</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">dwpc_head</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

                <span class="n">graph</span><span class="p">,</span>

                <span class="n">head</span><span class="p">,</span>

                <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

                <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

            <span class="p">)</span>

            <span class="n">dwpc_mid</span> <span class="o">=</span> <span class="n">dwpc_head</span> <span class="o">@</span> <span class="n">dwpc_mid</span>

        <span class="c1"># Multiply on the tail</span>

        <span class="k">if</span> <span class="n">tail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">rows</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_tail</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

                <span class="n">graph</span><span class="p">,</span>

                <span class="n">tail</span><span class="p">,</span>

                <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

                <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

                <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

            <span class="p">)</span>

            <span class="n">dwpc_mid</span> <span class="o">=</span> <span class="n">dwpc_mid</span> <span class="o">@</span> <span class="n">dwpc_tail</span>

        <span class="c1"># Remove the diagonal if the head and tail are repeats</span>

        <span class="k">if</span> <span class="n">head</span> <span class="ow">and</span> <span class="n">tail</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">head</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">tail</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

                <span class="n">dwpc_mid</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_mid</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_mid</span>

<span class="k">def</span> <span class="nf">_dwpc_baba</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Computes the degree-weighted path count for overlapping metanode</span>

<span class="sd">    repeats of the form B-A-B-A. Supports random inserts.</span>

<span class="sd">    Segment must start with B and end with A. AXBYAZB</span>

<span class="sd">    Also supports four-node repeats of a single node, including random,</span>

<span class="sd">    non-repeated inserts. For example, ABBBXBC, AAAA.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="n">seg_axb</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>

        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">seg_axb</span><span class="p">:</span>

            <span class="n">seg_axb</span> <span class="o">=</span> <span class="n">s</span>

            <span class="n">seg_bya</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">seg_azb</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>

            <span class="n">seg_cda</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="n">seg_bed</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">seg_azb</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># Collect segment DWPC and corrections</span>

    <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">axb</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">seg_axb</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span>

    <span class="p">)</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">bya</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">seg_bya</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span>

    <span class="p">)</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">azb</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">seg_azb</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span>

    <span class="p">)</span>

    <span class="n">correction_a</span> <span class="o">=</span> <span class="p">(</span>

        <span class="n">numpy</span><span class="o">.</span><span class="kp">diag</span><span class="p">((</span><span class="n">axb</span> <span class="o">@</span> <span class="n">bya</span><span class="p">)</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">())</span> <span class="o">@</span> <span class="n">azb</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">axb</span><span class="p">)</span>

        <span class="k">else</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">((</span><span class="n">axb</span> <span class="o">@</span> <span class="n">bya</span><span class="p">)</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">())</span> <span class="o">@</span> <span class="n">azb</span>

    <span class="p">)</span>

    <span class="n">correction_b</span> <span class="o">=</span> <span class="p">(</span>

        <span class="n">axb</span> <span class="o">@</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">diag</span><span class="p">((</span><span class="n">bya</span> <span class="o">@</span> <span class="n">azb</span><span class="p">)</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">bya</span><span class="p">)</span>

        <span class="k">else</span> <span class="n">axb</span> <span class="o">@</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">((</span><span class="n">bya</span> <span class="o">@</span> <span class="n">azb</span><span class="p">)</span><span class="o">.</span><span class="kp">diagonal</span><span class="p">())</span>

    <span class="p">)</span>

    <span class="n">correction_c</span> <span class="o">=</span> <span class="p">(</span>

        <span class="n">axb</span> <span class="o">*</span> <span class="n">bya</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">azb</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">bya</span><span class="p">)</span>

        <span class="k">else</span> <span class="p">(</span><span class="n">axb</span><span class="o">.</span><span class="kp">multiply</span><span class="p">(</span><span class="n">bya</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="kp">multiply</span><span class="p">(</span><span class="n">azb</span><span class="p">)</span>

    <span class="p">)</span>

    <span class="c1"># Apply the corrections</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">axb</span> <span class="o">@</span> <span class="n">bya</span> <span class="o">@</span> <span class="n">azb</span> <span class="o">-</span> <span class="n">correction_a</span> <span class="o">-</span> <span class="n">correction_b</span> <span class="o">+</span> <span class="n">correction_c</span>

    <span class="k">if</span> <span class="n">seg_axb</span><span class="o">.</span><span class="kp">source</span> <span class="o">==</span> <span class="n">seg_azb</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_matrix</span><span class="p">)</span>

    <span class="c1"># Account for possible head and tail segments outside the BABA group</span>

    <span class="k">if</span> <span class="n">seg_cda</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">cda</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span>

            <span class="n">seg_cda</span><span class="p">,</span>

            <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

            <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

        <span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">cda</span> <span class="o">@</span> <span class="n">dwpc_matrix</span>

    <span class="k">if</span> <span class="n">seg_bed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">bed</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span>

            <span class="n">seg_bed</span><span class="p">,</span>

            <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

            <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

        <span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">bed</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="k">def</span> <span class="nf">_dwpc_short_repeat</span><span class="p">(</span>

    <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>

<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    One metanode repeated 3 or fewer times (A-A-A), not (A-A-A-A)</span>

<span class="sd">    This can include other random inserts, so long as they are not</span>

<span class="sd">    repeats. Must start and end with the repeated node. Acceptable</span>

<span class="sd">    examples: (A-B-A-A), (A-B-A-C-D-E-F-A), (A-B-A-A), etc.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="n">get_segments</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span>

    <span class="c1"># Account for different head and tail possibilities.</span>

    <span class="n">head_segment</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">tail_segment</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">dwpc_tail</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Label the segments as head, tail, and repeat</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span> <span class="o">==</span> <span class="n">segment</span><span class="o">.</span><span class="n">target</span><span class="p">():</span>

            <span class="n">repeat_segment</span> <span class="o">=</span> <span class="n">segment</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">head_segment</span> <span class="o">=</span> <span class="n">segment</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">tail_segment</span> <span class="o">=</span> <span class="n">segment</span>

    <span class="c1"># Calculate DWPC for the middle (&quot;repeat&quot;) segment</span>

    <span class="n">repeated_metanode</span> <span class="o">=</span> <span class="n">repeat_segment</span><span class="o">.</span><span class="kp">source</span><span class="p">()</span>

    <span class="n">index_of_repeats</span> <span class="o">=</span> <span class="p">[</span>

        <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">repeat_segment</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">())</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">repeated_metanode</span>

    <span class="p">]</span>

    <span class="k">for</span> <span class="n">metaedge</span> <span class="ow">in</span> <span class="n">repeat_segment</span><span class="p">[:</span> <span class="n">index_of_repeats</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span> <span class="n">metaedge</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span>

        <span class="p">)</span>

        <span class="n">adj</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dwpc_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">row_names</span> <span class="o">=</span> <span class="n">rows</span>

            <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">adj</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">adj</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_matrix</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="c1"># Extra correction for random metanodes in the repeat segment</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_of_repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="k">for</span> <span class="n">metaedge</span> <span class="ow">in</span> <span class="n">repeat_segment</span><span class="p">[</span><span class="n">index_of_repeats</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:]:</span>

            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

                <span class="n">graph</span><span class="p">,</span> <span class="n">metaedge</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span> <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span>

            <span class="p">)</span>

            <span class="n">adj</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dwpc_tail</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">dwpc_tail</span> <span class="o">=</span> <span class="n">adj</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">dwpc_tail</span> <span class="o">=</span> <span class="n">dwpc_tail</span> <span class="o">@</span> <span class="n">adj</span>

        <span class="n">dwpc_tail</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_tail</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">dwpc_tail</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">remove_diag</span><span class="p">(</span><span class="n">dwpc_matrix</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">col_names</span> <span class="o">=</span> <span class="n">cols</span>

    <span class="k">if</span> <span class="n">head_segment</span><span class="p">:</span>

        <span class="n">row_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">head_dwpc</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span>

            <span class="n">head_segment</span><span class="p">,</span>

            <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

            <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

        <span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">head_dwpc</span> <span class="o">@</span> <span class="n">dwpc_matrix</span>

    <span class="k">if</span> <span class="n">tail_segment</span><span class="p">:</span>

        <span class="n">rows</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">tail_dwpc</span> <span class="o">=</span> <span class="n">dwpc</span><span class="p">(</span>

            <span class="n">graph</span><span class="p">,</span>

            <span class="n">tail_segment</span><span class="p">,</span>

            <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>

            <span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span>

            <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

        <span class="p">)</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">dwpc_matrix</span> <span class="o">@</span> <span class="n">tail_dwpc</span>

    <span class="k">return</span> <span class="n">row_names</span><span class="p">,</span> <span class="n">col_names</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="k">def</span> <span class="nf">_node_to_children</span><span class="p">(</span>

    <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">metapath_index</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>

<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Returns a history adjusted list of child nodes. Used in _dwpc_general_case.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    node : numpy.ndarray</span>

<span class="sd">    metapath_index : int</span>

<span class="sd">    damping : float</span>

<span class="sd">    history : numpy.ndarray</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    dict</span>

<span class="sd">        List of child nodes and a single numpy.ndarray of the newly</span>

<span class="sd">        updated history vector.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metaedge</span> <span class="o">=</span> <span class="n">metapath</span><span class="p">[</span><span class="n">metapath_index</span><span class="p">]</span>

    <span class="n">metanodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">())</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span>

    <span class="n">repeated</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">freq</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">history</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">history</span> <span class="o">=</span> <span class="p">{</span>

            <span class="n">i</span><span class="o">.</span><span class="n">target</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">ones</span><span class="p">(</span>

                <span class="nb">len</span><span class="p">(</span><span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>

                <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">,</span>

            <span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">metapath</span>

            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">target</span> <span class="ow">in</span> <span class="n">repeated</span>

        <span class="p">}</span>

    <span class="n">history</span> <span class="o">=</span> <span class="n">history</span><span class="o">.</span><span class="kp">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">metaedge</span><span class="o">.</span><span class="kp">source</span> <span class="ow">in</span> <span class="n">history</span><span class="p">:</span>

        <span class="n">history</span><span class="p">[</span><span class="n">metaedge</span><span class="o">.</span><span class="kp">source</span><span class="p">]</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">metaedge</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span>

    <span class="p">)</span>

    <span class="n">adj</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">vector</span> <span class="o">=</span> <span class="n">node</span> <span class="o">@</span> <span class="n">adj</span>

    <span class="k">if</span> <span class="n">metaedge</span><span class="o">.</span><span class="n">target</span> <span class="ow">in</span> <span class="n">history</span><span class="p">:</span>

        <span class="n">vector</span> <span class="o">*=</span> <span class="n">history</span><span class="p">[</span><span class="n">metaedge</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>

    <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">diag</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="kp">any</span><span class="p">()]</span>

    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="n">children</span><span class="p">,</span> <span class="s2">&quot;history&quot;</span><span class="p">:</span> <span class="n">history</span><span class="p">,</span> <span class="s2">&quot;next_index&quot;</span><span class="p">:</span> <span class="n">metapath_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">_dwpc_general_case</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    A slow but general function to compute the degree-weighted</span>

<span class="sd">    path count. Works by splitting the metapath at junctions</span>

<span class="sd">    where one node is joined to multiple nodes over a metaedge.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    graph : hetnetpy.hetnet.Graph</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    damping : float</span>

<span class="sd">    dtype : dtype object</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dwpc_step</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>

        <span class="n">_node_to_children</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="o">=</span><span class="n">metapath</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span>

    <span class="p">)</span>

    <span class="n">start_nodes</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="p">)</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">fin_nodes</span><span class="p">,</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">hetmatpy</span><span class="o">.</span><span class="kp">matrix</span><span class="o">.</span><span class="n">metaedge_to_adjacency_matrix</span><span class="p">(</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">metapath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="p">)</span>

    <span class="n">number_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_nodes</span><span class="p">)</span>

    <span class="n">number_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fin_nodes</span><span class="p">)</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_start</span><span class="p">):</span>

            <span class="n">search</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">zeros</span><span class="p">(</span><span class="n">number_start</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

            <span class="n">search</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">step1</span> <span class="o">=</span> <span class="p">[</span><span class="n">dwpc_step</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">search</span><span class="p">,</span> <span class="n">metapath_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="kc">None</span><span class="p">)]</span>

            <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">):</span>

                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">step2</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">step1</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]:</span>

                        <span class="n">hist</span> <span class="o">=</span> <span class="kp">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s2">&quot;history&quot;</span><span class="p">])</span>

                        <span class="n">out</span> <span class="o">=</span> <span class="n">dwpc_step</span><span class="p">(</span>

                            <span class="n">node</span><span class="o">=</span><span class="n">child</span><span class="p">,</span> <span class="n">metapath_index</span><span class="o">=</span><span class="n">group</span><span class="p">[</span><span class="s2">&quot;next_index&quot;</span><span class="p">],</span> <span class="n">history</span><span class="o">=</span><span class="n">hist</span>

                        <span class="p">)</span>

                        <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]:</span>

                            <span class="n">step2</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

                    <span class="n">step1</span> <span class="o">=</span> <span class="n">step2</span>

            <span class="n">final_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">group</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">step2</span> <span class="k">if</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]]</span>

            <span class="n">end_nodes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>

                <span class="n">child</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">final_children</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]</span>

            <span class="p">)</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

                <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">zeros</span><span class="p">(</span><span class="n">number_end</span><span class="p">)</span>

            <span class="n">dwpc_matrix</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">_degree_weight</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="n">dwpc_matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">dwpc_matrix</span><span class="p">,</span> <span class="kp">dtype</span><span class="o">=</span><span class="kp">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">start_nodes</span><span class="p">,</span> <span class="n">fin_nodes</span><span class="p">,</span> <span class="n">dwpc_matrix</span>

<span class="c1"># Default DWWC method to use, when not specified</span>

<span class="n">default_dwwc_method</span> <span class="o">=</span> <span class="n">dwwc_chain</span>
</code></pre></div>

</details>
<h2 id="functions">Functions</h2>
<h3 id="categorize">categorize</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">categorize</span><span class="p">(</span>
    <span class="n">metapath</span>
<span class="p">)</span>
</code></pre></div>

<p>Returns the classification of a given metapath as one of</p>
<p>a set of metapath types which we approach differently.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>metapath</td>
<td>hetnetpy.hetnet.MetaPath</td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>One of ['no_repeats', 'disjoint', 'short_repeat',</td>
</tr>
<tr>
<td>'long_repeat', 'BAAB', 'BABA', 'repeat_around',</td>
<td></td>
</tr>
<tr>
<td>'interior_complete_group', 'disjoint_groups', 'other']</td>
<td></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">categorize</span><span class="p">(</span><span class="n">metapath</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Returns the classification of a given metapath as one of</span>

<span class="sd">    a set of metapath types which we approach differently.</span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="sd">    Returns</span>

<span class="sd">    -------</span>

<span class="sd">    classification : string</span>

<span class="sd">        One of [&#39;no_repeats&#39;, &#39;disjoint&#39;, &#39;short_repeat&#39;,</span>

<span class="sd">                &#39;long_repeat&#39;, &#39;BAAB&#39;, &#39;BABA&#39;, &#39;repeat_around&#39;,</span>

<span class="sd">                 &#39;interior_complete_group&#39;, &#39;disjoint_groups&#39;, &#39;other&#39;]</span>

<span class="sd">    Examples</span>

<span class="sd">    --------</span>

<span class="sd">    GbCtDlA -&gt; &#39;no_repeats&#39;</span>

<span class="sd">    GiGiG   -&gt; &#39;short_repeat&#39;</span>

<span class="sd">    GiGiGcG -&gt; &#39;four_repeat&#39;</span>

<span class="sd">    GiGcGiGiG -&gt; &#39;long_repeat&#39;</span>

<span class="sd">    GiGbCrC -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GbCbGbC -&gt; &#39;BABA&#39;</span>

<span class="sd">    GbCrCbG -&gt; &#39;BAAB&#39;</span>

<span class="sd">    DaGiGbCrC -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GiGaDpCrC -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GiGbCrCpDrD -&gt; &#39;disjoint&#39;</span>

<span class="sd">    GbCpDaGbCpD -&gt; &#39;other&#39;</span>

<span class="sd">    GbCrCrCrCrCbG -&gt; &#39;other&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">metanodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">(</span><span class="n">metapath</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">())</span><span class="w"></span>

<span class="w">    </span><span class="n">freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">repeated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">metanode</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">metanode</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">freq</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">repeated</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;no_repeats&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">repeats_only</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">node</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">metanodes</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">repeated</span><span class="p">]</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Group neighbors if they are the same</span><span class="w"></span>

<span class="w">    </span><span class="n">grouped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">list</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)]</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Handle multiple disjoint repeats, any number, ie. AA,BB,CC,DD,...</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">):</span><span class="w"></span>

<span class="w">        </span><span class="c1"># Identify if there is only one metanode</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w"></span>

<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;short_repeat&quot;</span><span class="w"></span>

<span class="w">            </span><span class="k">elif</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w"></span>

<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;four_repeat&quot;</span><span class="w"></span>

<span class="w">            </span><span class="k">else</span><span class="p">:</span><span class="w"></span>

<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;long_repeat&quot;</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;disjoint&quot;</span><span class="w"></span>

<span class="w">    </span><span class="nb">assert</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Categorize the reformatted metapath</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="w"></span>

<span class="w">            </span><span class="nb">assert</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;BAAB&quot;</span><span class="w"></span>

<span class="w">        </span><span class="k">else</span><span class="p">:</span><span class="w"></span>

<span class="w">            </span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="w"></span>

<span class="w">                </span><span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>

<span class="w">                </span><span class="ow">and</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"></span>

<span class="w">            </span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;BABA&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">elif</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="n">map</span><span class="p">(</span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">grouped</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;BAAB&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">elif</span><span class="w"> </span><span class="n">repeats_only</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">list</span><span class="p">(</span><span class="n">reversed</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">))</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;BAAB&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># 6 node paths with 3x2 repeats</span><span class="w"></span>

<span class="w">    </span><span class="k">elif</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">repeats_only</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;repeat_around&quot;</span><span class="w"></span>

<span class="w">        </span><span class="c1"># AABCCB or AABCBC</span><span class="w"></span>

<span class="w">        </span><span class="k">elif</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;disjoint_groups&quot;</span><span class="w"></span>

<span class="w">        </span><span class="c1"># ABA CC B</span><span class="w"></span>

<span class="w">        </span><span class="k">elif</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">repeats_only</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;interior_complete_group&quot;</span><span class="w"></span>

<span class="w">        </span><span class="c1"># most complicated len 6</span><span class="w"></span>

<span class="w">        </span><span class="k">else</span><span class="p">:</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;other&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">else</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="c1"># Multi-repeats that aren&#39;t disjoint, eg. ABCBAC</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">repeated</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"></span>

<span class="w">            </span><span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="w"></span>

<span class="w">                </span><span class="n">f</span><span class="s2">&quot;{metapath}: Only two overlapping repeats currently supported&quot;</span><span class="w"></span>

<span class="w">            </span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;other&quot;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">metanodes</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w"></span>

<span class="w">            </span><span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="w"></span>

<span class="w">                </span><span class="n">f</span><span class="s2">&quot;{metapath}: Complex metapaths of length &gt; 4 are not yet &quot;</span><span class="w"> </span><span class="n">f</span><span class="s2">&quot;supported&quot;</span><span class="w"></span>

<span class="w">            </span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;other&quot;</span><span class="w"></span>

<span class="w">        </span><span class="nb">assert</span><span class="w"> </span><span class="n">False</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="default_dwwc_method">default_dwwc_method</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">default_dwwc_method</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;</span>
<span class="p">)</span>
</code></pre></div>

<p>Uses optimal matrix chain multiplication as in numpy.multi_dot, but allows</p>
<p>for sparse matrices. Uses ordering modified from numpy.linalg.linalg._multi_dot
(https://git.io/vh31f) which is released under a 3-Clause BSD License
(https://git.io/vhCDC).</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">dwwc_chain</span><span class="ss">(</span><span class="nv">graph</span>, <span class="nv">metapath</span>, <span class="nv">damping</span><span class="o">=</span><span class="mi">0</span>.<span class="mi">5</span>, <span class="nv">dense_threshold</span><span class="o">=</span><span class="mi">0</span>, <span class="nv">dtype</span><span class="o">=</span><span class="nv">numpy</span>.<span class="nv">float64</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Uses</span> <span class="nv">optimal</span> <span class="nv">matrix</span> <span class="nv">chain</span> <span class="nv">multiplication</span> <span class="nv">as</span> <span class="nv">in</span> <span class="nv">numpy</span>.<span class="nv">multi_dot</span>, <span class="nv">but</span> <span class="nv">allows</span>

    <span class="k">for</span> <span class="nv">sparse</span> <span class="nv">matrices</span>. <span class="nv">Uses</span> <span class="nv">ordering</span> <span class="nv">modified</span> <span class="nv">from</span> <span class="nv">numpy</span>.<span class="nv">linalg</span>.<span class="nv">linalg</span>.<span class="nv">_multi_dot</span>

    <span class="ss">(</span><span class="nv">https</span>:<span class="o">//</span><span class="nv">git</span>.<span class="nv">io</span><span class="o">/</span><span class="nv">vh31f</span><span class="ss">)</span> <span class="nv">which</span> <span class="nv">is</span> <span class="nv">released</span> <span class="nv">under</span> <span class="nv">a</span> <span class="mi">3</span><span class="o">-</span><span class="nv">Clause</span> <span class="nv">BSD</span> <span class="nv">License</span>

    <span class="ss">(</span><span class="nv">https</span>:<span class="o">//</span><span class="nv">git</span>.<span class="nv">io</span><span class="o">/</span><span class="nv">vhCDC</span><span class="ss">)</span>.

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">metapath</span> <span class="o">=</span> <span class="nv">graph</span>.<span class="nv">metagraph</span>.<span class="nv">get_metapath</span><span class="ss">(</span><span class="nv">metapath</span><span class="ss">)</span>

    <span class="nv">array_dims</span> <span class="o">=</span> [<span class="nv">graph</span>.<span class="nv">count_nodes</span><span class="ss">(</span><span class="nv">mn</span><span class="ss">)</span> <span class="k">for</span> <span class="nv">mn</span> <span class="nv">in</span> <span class="nv">metapath</span>.<span class="nv">get_nodes</span><span class="ss">()</span>]

    <span class="nv">row_ids</span> <span class="o">=</span> <span class="nv">hetmatpy</span>.<span class="nv">matrix</span>.<span class="nv">get_node_identifiers</span><span class="ss">(</span><span class="nv">graph</span>, <span class="nv">metapath</span>.<span class="nv">source</span><span class="ss">())</span>

    <span class="nv">columns_ids</span> <span class="o">=</span> <span class="nv">hetmatpy</span>.<span class="nv">matrix</span>.<span class="nv">get_node_identifiers</span><span class="ss">(</span><span class="nv">graph</span>, <span class="nv">metapath</span>.<span class="nv">target</span><span class="ss">())</span>

    <span class="nv">ordering</span> <span class="o">=</span> <span class="nv">_dimensions_to_ordering</span><span class="ss">(</span><span class="nv">array_dims</span><span class="ss">)</span>

    <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">_multi_dot</span><span class="ss">(</span>

        <span class="nv">metapath</span>, <span class="nv">ordering</span>, <span class="mi">0</span>, <span class="nv">len</span><span class="ss">(</span><span class="nv">metapath</span><span class="ss">)</span> <span class="o">-</span> <span class="mi">1</span>, <span class="nv">graph</span>, <span class="nv">damping</span>, <span class="nv">dense_threshold</span>, <span class="nv">dtype</span>

    <span class="ss">)</span>

    <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">sparsify_or_densify</span><span class="ss">(</span><span class="nv">dwwc_matrix</span>, <span class="nv">dense_threshold</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">row_ids</span>, <span class="nv">columns_ids</span>, <span class="nv">dwwc_matrix</span>
</code></pre></div>

</details>
<h3 id="dwpc">dwpc</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">dwpc</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">approx_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;,</span>
    <span class="n">dwwc_method</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>

<p>A unified function to compute the degree-weighted path count.</p>
<p>This function will call get_segments, then the appropriate
specialized (or generalized) DWPC function.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>graph</td>
<td>hetnetpy.hetnet.Graph</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>metapath</td>
<td>hetnetpy.hetnet.MetaPath</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>damping</td>
<td>float</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>dense_threshold</td>
<td>float (0 &lt;= dense_threshold &lt;= 1)</td>
<td>sets the density threshold above which a sparse matrix will be</td>
<td></td>
</tr>
<tr>
<td>converted to a dense automatically.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>approx_ok</td>
<td>bool</td>
<td>if True, uses an approximation to DWPC. If False, dwpc will call</td>
<td></td>
</tr>
<tr>
<td>_dwpc_general_case and give a warning on metapaths which are</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>categorized 'other' and 'long_repeat'..</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>dtype</td>
<td>dtype object</td>
<td>numpy.float32 or numpy.float64. At present, numpy.float16 fails when</td>
<td></td>
</tr>
<tr>
<td>using sparse matrices, due to a bug in scipy.sparse</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>dwwc_method</td>
<td>function</td>
<td>dwwc method to use for computing DWWCs. If set to None, use</td>
<td></td>
</tr>
<tr>
<td>module-level default (default_dwwc_method).</td>
<td>_dwwc_method</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>numpy.ndarray</td>
<td>row labels</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">@path_count_cache</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="ss">&quot;dwpc&quot;</span><span class="p">)</span><span class="w"></span>

<span class="n">def</span><span class="w"> </span><span class="n">dwpc</span><span class="p">(</span><span class="w"></span>

<span class="w">    </span><span class="n">graph</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">metapath</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">approx_ok</span><span class="o">=</span><span class="k">False</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="p">.</span><span class="n">float64</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">dwwc_method</span><span class="o">=</span><span class="k">None</span><span class="p">,</span><span class="w"></span>

<span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    A unified function to compute the degree-weighted path count.</span>

<span class="ss">    This function will call get_segments, then the appropriate</span>

<span class="ss">    specialized (or generalized) DWPC function.</span>

<span class="ss">    Parameters</span>

<span class="ss">    ----------</span>

<span class="ss">    graph : hetnetpy.hetnet.Graph</span>

<span class="ss">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="ss">    damping : float</span>

<span class="ss">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="ss">        sets the density threshold above which a sparse matrix will be</span>

<span class="ss">        converted to a dense automatically.</span>

<span class="ss">    approx_ok : bool</span>

<span class="ss">        if True, uses an approximation to DWPC. If False, dwpc will call</span>

<span class="ss">        _dwpc_general_case and give a warning on metapaths which are</span>

<span class="ss">        categorized &#39;other&#39; and &#39;long_repeat&#39;..</span>

<span class="ss">    dtype : dtype object</span>

<span class="ss">        numpy.float32 or numpy.float64. At present, numpy.float16 fails when</span>

<span class="ss">        using sparse matrices, due to a bug in scipy.sparse</span>

<span class="ss">    dwwc_method : function</span>

<span class="ss">        dwwc method to use for computing DWWCs. If set to None, use</span>

<span class="ss">        module-level default (default_dwwc_method).</span>

<span class="ss">    Returns</span>

<span class="ss">    -------</span>

<span class="ss">    numpy.ndarray</span>

<span class="ss">        row labels</span>

<span class="ss">    numpy.ndarray</span>

<span class="ss">        column labels</span>

<span class="ss">    numpy.ndarray or scipy.sparse.csc_matrix</span>

<span class="ss">        the DWPC matrix</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">categorize</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">dwpc_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_category_to_function</span><span class="p">(</span><span class="n">category</span><span class="p">,</span><span class="w"> </span><span class="n">dwwc_method</span><span class="o">=</span><span class="n">dwwc_method</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">category</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="ss">&quot;long_repeat&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;other&quot;</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nl">approx_ok</span><span class="p">:</span><span class="w"></span>

<span class="w">            </span><span class="n">dwpc_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_dwpc_approx</span><span class="w"></span>

<span class="w">        </span><span class="k">else</span><span class="err">:</span><span class="w"></span>

<span class="w">            </span><span class="n">logging</span><span class="p">.</span><span class="n">warning</span><span class="p">(</span><span class="w"></span>

<span class="w">                </span><span class="n">f</span><span class="ss">&quot;Metapath {metapath} will use _dwpc_general_case, &quot;</span><span class="w"></span>

<span class="w">                </span><span class="ss">&quot;which can require very long computations.&quot;</span><span class="w"></span>

<span class="w">            </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">row_names</span><span class="p">,</span><span class="w"> </span><span class="n">col_names</span><span class="p">,</span><span class="w"> </span><span class="n">dwpc_matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dwpc_function</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="n">metapath</span><span class="p">,</span><span class="w"> </span><span class="n">damping</span><span class="p">,</span><span class="w"> </span><span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span><span class="w"> </span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">row_names</span><span class="p">,</span><span class="w"> </span><span class="n">col_names</span><span class="p">,</span><span class="w"> </span><span class="n">dwpc_matrix</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="dwwc">dwwc</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">dwwc</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;,</span>
    <span class="n">dwwc_method</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>

<p>Compute the degree-weighted walk count (DWWC) in which nodes can be</p>
<p>repeated within a path.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>graph</td>
<td>hetnetpy.hetnet.Graph</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>metapath</td>
<td>hetnetpy.hetnet.MetaPath</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>damping</td>
<td>float</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>dense_threshold</td>
<td>float (0 &lt;= dense_threshold &lt;= 1)</td>
<td>sets the density threshold at which a sparse matrix will be</td>
<td></td>
</tr>
<tr>
<td>converted to a dense automatically.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>dtype</td>
<td>dtype object</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>dwwc_method</td>
<td>function</td>
<td>dwwc method to use for computing DWWCs. If set to None, use</td>
<td></td>
</tr>
<tr>
<td>module-level default (default_dwwc_method).</td>
<td>_dwwc_method</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">@path_count_cache</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="ss">&quot;dwwc&quot;</span><span class="p">)</span><span class="w"></span>

<span class="n">def</span><span class="w"> </span><span class="n">dwwc</span><span class="p">(</span><span class="w"></span>

<span class="w">    </span><span class="n">graph</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">metapath</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="p">.</span><span class="n">float64</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">dwwc_method</span><span class="o">=</span><span class="k">None</span><span class="p">,</span><span class="w"></span>

<span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    Compute the degree-weighted walk count (DWWC) in which nodes can be</span>

<span class="ss">    repeated within a path.</span>

<span class="ss">    Parameters</span>

<span class="ss">    ----------</span>

<span class="ss">    graph : hetnetpy.hetnet.Graph</span>

<span class="ss">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="ss">    damping : float</span>

<span class="ss">    dense_threshold : float (0 &lt;= dense_threshold &lt;= 1)</span>

<span class="ss">        sets the density threshold at which a sparse matrix will be</span>

<span class="ss">        converted to a dense automatically.</span>

<span class="ss">    dtype : dtype object</span>

<span class="ss">    dwwc_method : function</span>

<span class="ss">        dwwc method to use for computing DWWCs. If set to None, use</span>

<span class="ss">        module-level default (default_dwwc_method).</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">dwwc_method</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">metapath</span><span class="o">=</span><span class="n">metapath</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">dense_threshold</span><span class="o">=</span><span class="n">dense_threshold</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="dwwc_chain">dwwc_chain</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">dwwc_chain</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;</span>
<span class="p">)</span>
</code></pre></div>

<p>Uses optimal matrix chain multiplication as in numpy.multi_dot, but allows</p>
<p>for sparse matrices. Uses ordering modified from numpy.linalg.linalg._multi_dot
(https://git.io/vh31f) which is released under a 3-Clause BSD License
(https://git.io/vhCDC).</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">dwwc_chain</span><span class="ss">(</span><span class="nv">graph</span>, <span class="nv">metapath</span>, <span class="nv">damping</span><span class="o">=</span><span class="mi">0</span>.<span class="mi">5</span>, <span class="nv">dense_threshold</span><span class="o">=</span><span class="mi">0</span>, <span class="nv">dtype</span><span class="o">=</span><span class="nv">numpy</span>.<span class="nv">float64</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Uses</span> <span class="nv">optimal</span> <span class="nv">matrix</span> <span class="nv">chain</span> <span class="nv">multiplication</span> <span class="nv">as</span> <span class="nv">in</span> <span class="nv">numpy</span>.<span class="nv">multi_dot</span>, <span class="nv">but</span> <span class="nv">allows</span>

    <span class="k">for</span> <span class="nv">sparse</span> <span class="nv">matrices</span>. <span class="nv">Uses</span> <span class="nv">ordering</span> <span class="nv">modified</span> <span class="nv">from</span> <span class="nv">numpy</span>.<span class="nv">linalg</span>.<span class="nv">linalg</span>.<span class="nv">_multi_dot</span>

    <span class="ss">(</span><span class="nv">https</span>:<span class="o">//</span><span class="nv">git</span>.<span class="nv">io</span><span class="o">/</span><span class="nv">vh31f</span><span class="ss">)</span> <span class="nv">which</span> <span class="nv">is</span> <span class="nv">released</span> <span class="nv">under</span> <span class="nv">a</span> <span class="mi">3</span><span class="o">-</span><span class="nv">Clause</span> <span class="nv">BSD</span> <span class="nv">License</span>

    <span class="ss">(</span><span class="nv">https</span>:<span class="o">//</span><span class="nv">git</span>.<span class="nv">io</span><span class="o">/</span><span class="nv">vhCDC</span><span class="ss">)</span>.

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">metapath</span> <span class="o">=</span> <span class="nv">graph</span>.<span class="nv">metagraph</span>.<span class="nv">get_metapath</span><span class="ss">(</span><span class="nv">metapath</span><span class="ss">)</span>

    <span class="nv">array_dims</span> <span class="o">=</span> [<span class="nv">graph</span>.<span class="nv">count_nodes</span><span class="ss">(</span><span class="nv">mn</span><span class="ss">)</span> <span class="k">for</span> <span class="nv">mn</span> <span class="nv">in</span> <span class="nv">metapath</span>.<span class="nv">get_nodes</span><span class="ss">()</span>]

    <span class="nv">row_ids</span> <span class="o">=</span> <span class="nv">hetmatpy</span>.<span class="nv">matrix</span>.<span class="nv">get_node_identifiers</span><span class="ss">(</span><span class="nv">graph</span>, <span class="nv">metapath</span>.<span class="nv">source</span><span class="ss">())</span>

    <span class="nv">columns_ids</span> <span class="o">=</span> <span class="nv">hetmatpy</span>.<span class="nv">matrix</span>.<span class="nv">get_node_identifiers</span><span class="ss">(</span><span class="nv">graph</span>, <span class="nv">metapath</span>.<span class="nv">target</span><span class="ss">())</span>

    <span class="nv">ordering</span> <span class="o">=</span> <span class="nv">_dimensions_to_ordering</span><span class="ss">(</span><span class="nv">array_dims</span><span class="ss">)</span>

    <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">_multi_dot</span><span class="ss">(</span>

        <span class="nv">metapath</span>, <span class="nv">ordering</span>, <span class="mi">0</span>, <span class="nv">len</span><span class="ss">(</span><span class="nv">metapath</span><span class="ss">)</span> <span class="o">-</span> <span class="mi">1</span>, <span class="nv">graph</span>, <span class="nv">damping</span>, <span class="nv">dense_threshold</span>, <span class="nv">dtype</span>

    <span class="ss">)</span>

    <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">sparsify_or_densify</span><span class="ss">(</span><span class="nv">dwwc_matrix</span>, <span class="nv">dense_threshold</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">row_ids</span>, <span class="nv">columns_ids</span>, <span class="nv">dwwc_matrix</span>
</code></pre></div>

</details>
<h3 id="dwwc_recursive">dwwc_recursive</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">dwwc_recursive</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;</span>
<span class="p">)</span>
</code></pre></div>

<p>Recursive DWWC implementation to take better advantage of caching.</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">dwwc_recursive</span><span class="ss">(</span>

    <span class="nv">graph</span>, <span class="nv">metapath</span>, <span class="nv">damping</span><span class="o">=</span><span class="mi">0</span>.<span class="mi">5</span>, <span class="nv">dense_threshold</span><span class="o">=</span><span class="mi">0</span>, <span class="nv">dtype</span><span class="o">=</span><span class="nv">numpy</span>.<span class="nv">float64</span>

<span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Recursive</span> <span class="nv">DWWC</span> <span class="nv">implementation</span> <span class="nv">to</span> <span class="nv">take</span> <span class="nv">better</span> <span class="nv">advantage</span> <span class="nv">of</span> <span class="nv">caching</span>.

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">rows</span>, <span class="nv">cols</span>, <span class="nv">adj_mat</span> <span class="o">=</span> <span class="nv">hetmatpy</span>.<span class="nv">matrix</span>.<span class="nv">metaedge_to_adjacency_matrix</span><span class="ss">(</span>

        <span class="nv">graph</span>, <span class="nv">metapath</span>[<span class="mi">0</span>], <span class="nv">dense_threshold</span><span class="o">=</span><span class="nv">dense_threshold</span>, <span class="nv">dtype</span><span class="o">=</span><span class="nv">dtype</span>

    <span class="ss">)</span>

    <span class="nv">adj_mat</span> <span class="o">=</span> <span class="nv">_degree_weight</span><span class="ss">(</span><span class="nv">adj_mat</span>, <span class="nv">damping</span>, <span class="nv">dtype</span><span class="o">=</span><span class="nv">dtype</span><span class="ss">)</span>

    <span class="k">if</span> <span class="nv">len</span><span class="ss">(</span><span class="nv">metapath</span><span class="ss">)</span> <span class="o">&gt;</span> <span class="mi">1</span>:

        <span class="nv">_</span>, <span class="nv">cols</span>, <span class="nv">dwwc_next</span> <span class="o">=</span> <span class="nv">dwwc</span><span class="ss">(</span>

            <span class="nv">graph</span>,

            <span class="nv">metapath</span>[<span class="mi">1</span>:],

            <span class="nv">damping</span><span class="o">=</span><span class="nv">damping</span>,

            <span class="nv">dense_threshold</span><span class="o">=</span><span class="nv">dense_threshold</span>,

            <span class="nv">dtype</span><span class="o">=</span><span class="nv">dtype</span>,

            <span class="nv">dwwc_method</span><span class="o">=</span><span class="nv">dwwc_recursive</span>,

        <span class="ss">)</span>

        <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">adj_mat</span> @ <span class="nv">dwwc_next</span>

    <span class="k">else</span>:

        <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">adj_mat</span>

    <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">sparsify_or_densify</span><span class="ss">(</span><span class="nv">dwwc_matrix</span>, <span class="nv">dense_threshold</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">rows</span>, <span class="nv">cols</span>, <span class="nv">dwwc_matrix</span>
</code></pre></div>

</details>
<h3 id="dwwc_sequential">dwwc_sequential</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">dwwc_sequential</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">metapath</span><span class="p">,</span>
    <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">dense_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;</span>
<span class="p">)</span>
</code></pre></div>

<p>Compute the degree-weighted walk count (DWWC) in which nodes can be</p>
<p>repeated within a path.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>graph</td>
<td>hetnetpy.hetnet.Graph</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>metapath</td>
<td>hetnetpy.hetnet.MetaPath</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>damping</td>
<td>float</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>dense_threshold</td>
<td>float (0 &lt;= dense_threshold &lt;= 1)</td>
<td>sets the density threshold at which a sparse matrix will be</td>
<td></td>
</tr>
<tr>
<td>converted to a dense automatically.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>dtype</td>
<td>dtype object</td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">dwwc_sequential</span><span class="ss">(</span>

    <span class="nv">graph</span>, <span class="nv">metapath</span>, <span class="nv">damping</span><span class="o">=</span><span class="mi">0</span>.<span class="mi">5</span>, <span class="nv">dense_threshold</span><span class="o">=</span><span class="mi">0</span>, <span class="nv">dtype</span><span class="o">=</span><span class="nv">numpy</span>.<span class="nv">float64</span>

<span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Compute</span> <span class="nv">the</span> <span class="nv">degree</span><span class="o">-</span><span class="nv">weighted</span> <span class="nv">walk</span> <span class="nv">count</span> <span class="ss">(</span><span class="nv">DWWC</span><span class="ss">)</span> <span class="nv">in</span> <span class="nv">which</span> <span class="nv">nodes</span> <span class="nv">can</span> <span class="nv">be</span>

    <span class="nv">repeated</span> <span class="nv">within</span> <span class="nv">a</span> <span class="nv">path</span>.

    <span class="nv">Parameters</span>

    <span class="o">----------</span>

    <span class="nv">graph</span> : <span class="nv">hetnetpy</span>.<span class="nv">hetnet</span>.<span class="nv">Graph</span>

    <span class="nv">metapath</span> : <span class="nv">hetnetpy</span>.<span class="nv">hetnet</span>.<span class="nv">MetaPath</span>

    <span class="nv">damping</span> : <span class="nv">float</span>

    <span class="nv">dense_threshold</span> : <span class="nv">float</span> <span class="ss">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="nv">dense_threshold</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="ss">)</span>

        <span class="nv">sets</span> <span class="nv">the</span> <span class="nv">density</span> <span class="nv">threshold</span> <span class="nv">at</span> <span class="nv">which</span> <span class="nv">a</span> <span class="nv">sparse</span> <span class="nv">matrix</span> <span class="nv">will</span> <span class="nv">be</span>

        <span class="nv">converted</span> <span class="nv">to</span> <span class="nv">a</span> <span class="nv">dense</span> <span class="nv">automatically</span>.

    <span class="nv">dtype</span> : <span class="nv">dtype</span> <span class="nv">object</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">None</span>

    <span class="nv">row_names</span> <span class="o">=</span> <span class="nv">None</span>

    <span class="k">for</span> <span class="nv">metaedge</span> <span class="nv">in</span> <span class="nv">metapath</span>:

        <span class="nv">rows</span>, <span class="nv">cols</span>, <span class="nv">adj_mat</span> <span class="o">=</span> <span class="nv">hetmatpy</span>.<span class="nv">matrix</span>.<span class="nv">metaedge_to_adjacency_matrix</span><span class="ss">(</span>

            <span class="nv">graph</span>, <span class="nv">metaedge</span>, <span class="nv">dense_threshold</span><span class="o">=</span><span class="nv">dense_threshold</span>, <span class="nv">dtype</span><span class="o">=</span><span class="nv">dtype</span>

        <span class="ss">)</span>

        <span class="nv">adj_mat</span> <span class="o">=</span> <span class="nv">_degree_weight</span><span class="ss">(</span><span class="nv">adj_mat</span>, <span class="nv">damping</span>, <span class="nv">dtype</span><span class="o">=</span><span class="nv">dtype</span><span class="ss">)</span>

        <span class="k">if</span> <span class="nv">dwwc_matrix</span> <span class="nv">is</span> <span class="nv">None</span>:

            <span class="nv">row_names</span> <span class="o">=</span> <span class="nv">rows</span>

            <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">adj_mat</span>

        <span class="k">else</span>:

            <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">dwwc_matrix</span> @ <span class="nv">adj_mat</span>

            <span class="nv">dwwc_matrix</span> <span class="o">=</span> <span class="nv">sparsify_or_densify</span><span class="ss">(</span><span class="nv">dwwc_matrix</span>, <span class="nv">dense_threshold</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">row_names</span>, <span class="nv">cols</span>, <span class="nv">dwwc_matrix</span>
</code></pre></div>

</details>
<h3 id="get_all_segments">get_all_segments</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_all_segments</span><span class="p">(</span>
    <span class="n">metagraph</span><span class="p">,</span>
    <span class="n">metapath</span>
<span class="p">)</span>
</code></pre></div>

<p>Return all subsegments of a given metapath, including those segments that</p>
<p>appear only after early splits.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>metagraph</td>
<td>hetnetpy.hetnet.MetaGraph</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>metapath</td>
<td>hetnetpy.hetnet.MetaPath</td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td>None</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span><span class="w"> </span><span class="n">metapath</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    Return all subsegments of a given metapath, including those segments that</span>

<span class="ss">    appear only after early splits.</span>

<span class="ss">    Parameters</span>

<span class="ss">    ----------</span>

<span class="ss">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="ss">    metapath : hetnetpy.hetnet.MetaPath</span>

<span class="ss">    Returns</span>

<span class="ss">    -------</span>

<span class="ss">    list</span>

<span class="ss">    Example</span>

<span class="ss">    -------</span>

<span class="ss">    &gt;&gt;&gt; get_all_segments(metagraph, CrCbGaDrDaG)</span>

<span class="ss">    [CrC, CbG, GaDrDaG, GaD, DrD, DaG]</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">metapath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">metagraph</span><span class="p">.</span><span class="n">get_metapath</span><span class="p">(</span><span class="n">metapath</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">segments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span><span class="w"> </span><span class="n">metapath</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">[</span><span class="n">metapath</span><span class="o">]</span><span class="w"></span>

<span class="w">    </span><span class="n">all_subsegments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">metapath</span><span class="o">]</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">segment</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">segments</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="n">subsegments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span><span class="w"> </span><span class="n">segment</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">next_split</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subsegments</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">subsegments</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="err">[]</span><span class="w"></span>

<span class="w">        </span><span class="n">all_subsegments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">all_subsegments</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">[</span><span class="n">segment</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">next_split</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">all_subsegments</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="get_segments">get_segments</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span>
    <span class="n">metagraph</span><span class="p">,</span>
    <span class="n">metapath</span>
<span class="p">)</span>
</code></pre></div>

<p>Split a metapath into segments of recognized groups and non-repeated</p>
<p>nodes. Groups include BAAB, BABA, disjoint short- and long-repeats.
Returns an error for categorization 'other'.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>metagraph</td>
<td>hetnetpy.hetnet.MetaGraph</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>metapath</td>
<td>hetnetpy.hetnet.Metapath</td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td>list of metapaths. If the metapath is not segmentable or is already</td>
</tr>
<tr>
<td>fully simplified (eg. GiGaDaG), then the list will have only one</td>
<td></td>
</tr>
<tr>
<td>element.</td>
<td></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="s s-Atom">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="s s-Atom">metagraph</span><span class="p">,</span> <span class="s s-Atom">metapath</span><span class="p">)</span><span class="s s-Atom">:</span>

    <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    Split a metapath into segments of recognized groups and non-repeated</span>

<span class="s2">    nodes. Groups include BAAB, BABA, disjoint short- and long-repeats.</span>

<span class="s2">    Returns an error for categorization &#39;other&#39;.</span>

<span class="s2">    Parameters</span>

<span class="s2">    ----------</span>

<span class="s2">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="s2">    metapath : hetnetpy.hetnet.Metapath</span>

<span class="s2">    Returns</span>

<span class="s2">    -------</span>

<span class="s2">    list</span>

<span class="s2">        list of metapaths. If the metapath is not segmentable or is already</span>

<span class="s2">        fully simplified (eg. GiGaDaG), then the list will have only one</span>

<span class="s2">        element.</span>

<span class="s2">    Examples</span>

<span class="s2">    --------</span>

<span class="s2">    &#39;CbGaDaGaD&#39; -&gt; [&#39;CbG&#39;, &#39;GaD&#39;, &#39;GaG&#39;, &#39;GaD&#39;]</span>

<span class="s2">    &#39;GbCpDaGaD&#39; -&gt; [&#39;GbCpD&#39;, &#39;DaG&#39;, &#39;GaD&#39;]</span>

<span class="s2">    &#39;CrCbGiGaDrD&#39; -&gt; [&#39;CrC&#39;, &#39;CbG&#39;, &#39;GiG&#39;, &#39;GaD&#39;, &#39;DrD&#39;]</span>

<span class="s2">    &quot;&quot;&quot;</span>

    <span class="s s-Atom">def</span> <span class="nf">add_head_tail</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">,</span> <span class="s s-Atom">indices</span><span class="p">)</span><span class="s s-Atom">:</span>

        <span class="s2">&quot;&quot;&quot;Makes sure that all metanodes are included in segments.</span>

<span class="s2">        Ensures that the first segment goes all the way back to the</span>

<span class="s2">        first metanode. Similarly, makes sure that the last segment</span>

<span class="s2">        includes all metanodes up to the last one.&quot;&quot;&quot;</span>

        <span class="s s-Atom">#</span> <span class="s s-Atom">handle</span> <span class="s s-Atom">non</span><span class="o">-</span><span class="s s-Atom">duplicated</span> <span class="s s-Atom">on</span> <span class="s s-Atom">the</span> <span class="s s-Atom">front</span>

        <span class="s s-Atom">if</span> <span class="s s-Atom">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">!</span><span class="o">=</span> <span class="mi">0</span><span class="s s-Atom">:</span>

            <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s s-Atom">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span> <span class="o">+</span> <span class="s s-Atom">indices</span>

        <span class="s s-Atom">#</span> <span class="s s-Atom">handle</span> <span class="s s-Atom">non</span><span class="o">-</span><span class="s s-Atom">duplicated</span> <span class="s s-Atom">on</span> <span class="s s-Atom">the</span> <span class="s s-Atom">end</span>

        <span class="s s-Atom">if</span> <span class="s s-Atom">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">!</span><span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">)</span><span class="s s-Atom">:</span>

            <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="s s-Atom">indices</span> <span class="o">+</span> <span class="p">[(</span><span class="s s-Atom">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">))]</span>

        <span class="s s-Atom">return</span> <span class="s s-Atom">indices</span>

    <span class="s s-Atom">metapath</span> <span class="o">=</span> <span class="s s-Atom">metagraph</span><span class="p">.</span><span class="nf">get_metapath</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">)</span>

    <span class="s s-Atom">category</span> <span class="o">=</span> <span class="nf">categorize</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">)</span>

    <span class="s s-Atom">metanodes</span> <span class="o">=</span> <span class="s s-Atom">metapath</span><span class="p">.</span><span class="nf">get_nodes</span><span class="p">()</span>

    <span class="s s-Atom">freq</span> <span class="o">=</span> <span class="s s-Atom">collections</span><span class="p">.</span><span class="nv">Counter</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)</span>

    <span class="s s-Atom">repeated</span> <span class="o">=</span> <span class="p">{</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">freq</span><span class="p">.</span><span class="nf">keys</span><span class="p">()</span> <span class="s s-Atom">if</span> <span class="s s-Atom">freq</span><span class="p">[</span><span class="s s-Atom">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>

    <span class="s s-Atom">if</span> <span class="s s-Atom">category</span> <span class="o">==</span> <span class="s2">&quot;no_repeats&quot;</span><span class="s s-Atom">:</span>

        <span class="s s-Atom">return</span> <span class="p">[</span><span class="s s-Atom">metapath</span><span class="p">]</span>

    <span class="s s-Atom">elif</span> <span class="s s-Atom">category</span> <span class="o">==</span> <span class="s2">&quot;repeat_around&quot;</span><span class="s s-Atom">:</span>

        <span class="s s-Atom">#</span> <span class="nv">Note</span> <span class="s s-Atom">this</span> <span class="o">is</span> <span class="s s-Atom">hard</span><span class="o">-</span><span class="s s-Atom">coded</span> <span class="s s-Atom">and</span> <span class="s s-Atom">will</span> <span class="s s-Atom">need</span> <span class="s s-Atom">to</span> <span class="s s-Atom">be</span> <span class="s s-Atom">updated</span> <span class="s s-Atom">for</span> <span class="s s-Atom">various</span>

        <span class="s s-Atom">#</span> <span class="s s-Atom">metapath</span> <span class="s s-Atom">lengths</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

    <span class="s s-Atom">elif</span> <span class="s s-Atom">category</span> <span class="o">==</span> <span class="s2">&quot;disjoint_groups&quot;</span><span class="s s-Atom">:</span>

        <span class="s s-Atom">#</span> <span class="nv">CCBABA</span> <span class="s s-Atom">or</span> <span class="nv">CCBAAB</span> <span class="s s-Atom">or</span> <span class="nv">BABACC</span> <span class="s s-Atom">or</span> <span class="nv">BAABCC</span> <span class="s s-Atom">-&gt;</span> <span class="p">[</span><span class="nv">CC</span><span class="p">,</span> <span class="nv">BABA</span><span class="p">],</span> <span class="s s-Atom">etc</span><span class="p">.</span>

        <span class="s s-Atom">metanodes</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">.</span><span class="nf">get_nodes</span><span class="p">())</span>

        <span class="s s-Atom">grouped</span> <span class="o">=</span> <span class="p">[</span><span class="nf">list</span><span class="p">(</span><span class="s s-Atom">v</span><span class="p">)</span> <span class="s s-Atom">for</span> <span class="s s-Atom">k</span><span class="p">,</span> <span class="s s-Atom">v</span> <span class="s s-Atom">in</span> <span class="s s-Atom">itertools</span><span class="p">.</span><span class="nf">groupby</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)]</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="p">(</span>

            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

            <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">grouped</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span>

            <span class="s s-Atom">else</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

        <span class="p">)</span>

    <span class="s s-Atom">elif</span> <span class="s s-Atom">category</span> <span class="nf">in</span> <span class="p">(</span><span class="s2">&quot;disjoint&quot;</span><span class="p">,</span> <span class="s2">&quot;short_repeat&quot;</span><span class="p">,</span> <span class="s2">&quot;long_repeat&quot;</span><span class="p">)</span><span class="s s-Atom">:</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span>

            <span class="p">[</span><span class="s s-Atom">metanodes</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">)</span> <span class="o">-</span> <span class="nf">list</span><span class="p">(</span><span class="nf">reversed</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)).</span><span class="nf">index</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">)]</span>

            <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeated</span>

        <span class="p">)</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">add_head_tail</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">,</span> <span class="s s-Atom">indices</span><span class="p">)</span>

        <span class="s s-Atom">#</span> <span class="s s-Atom">handle</span> <span class="s s-Atom">middle</span> <span class="s s-Atom">cases</span> <span class="s s-Atom">with</span> <span class="s s-Atom">non</span><span class="o">-</span><span class="s s-Atom">repeated</span> <span class="s s-Atom">nodes</span> <span class="s s-Atom">between</span> <span class="s s-Atom">disjoint</span> <span class="s s-Atom">regions</span>

        <span class="s s-Atom">#</span> <span class="nv">Eg</span><span class="p">.</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span> <span class="s s-Atom">-&gt;</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>

        <span class="s s-Atom">inds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="s s-Atom">for</span> <span class="s s-Atom">i</span><span class="p">,</span> <span class="s s-Atom">v</span> <span class="s s-Atom">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="s s-Atom">indices</span><span class="p">[:-</span><span class="mi">1</span><span class="p">])</span><span class="s s-Atom">:</span>

            <span class="s s-Atom">inds</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">v</span><span class="p">)</span>

            <span class="s s-Atom">if</span> <span class="s s-Atom">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">!</span><span class="o">=</span> <span class="s s-Atom">indices</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">inds</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="s s-Atom">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s s-Atom">indices</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="s s-Atom">inds</span> <span class="o">+</span> <span class="p">[</span><span class="s s-Atom">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="s s-Atom">elif</span> <span class="s s-Atom">category</span> <span class="o">==</span> <span class="s2">&quot;four_repeat&quot;</span><span class="s s-Atom">:</span>

        <span class="s s-Atom">nodes</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)</span>

        <span class="s s-Atom">repeat_indices</span> <span class="o">=</span> <span class="p">[</span>

            <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span><span class="p">,</span> <span class="s s-Atom">v</span> <span class="s s-Atom">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)</span> <span class="s s-Atom">if</span> <span class="s s-Atom">v</span> <span class="o">==</span> <span class="s s-Atom">metanode</span><span class="p">]</span> <span class="s s-Atom">for</span> <span class="s s-Atom">metanode</span> <span class="s s-Atom">in</span> <span class="s s-Atom">nodes</span>

        <span class="p">]</span>

        <span class="s s-Atom">repeat_indices</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeat_indices</span> <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

        <span class="s s-Atom">simple_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">group</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeat_indices</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">group</span><span class="p">]</span>

        <span class="s s-Atom">seconds</span> <span class="o">=</span> <span class="s s-Atom">simple_repeats</span><span class="p">[</span><span class="mi">1</span><span class="s s-Atom">:</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s s-Atom">simple_repeats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="s s-Atom">simple_repeats</span><span class="p">,</span> <span class="s s-Atom">seconds</span><span class="p">))</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">add_head_tail</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">,</span> <span class="s s-Atom">indices</span><span class="p">)</span>

    <span class="s s-Atom">elif</span> <span class="s s-Atom">category</span> <span class="nf">in</span> <span class="p">(</span><span class="s2">&quot;BAAB&quot;</span><span class="p">,</span> <span class="s2">&quot;BABA&quot;</span><span class="p">,</span> <span class="s2">&quot;other&quot;</span><span class="p">,</span> <span class="s2">&quot;interior_complete_group&quot;</span><span class="p">)</span><span class="s s-Atom">:</span>

        <span class="s s-Atom">nodes</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)</span>

        <span class="s s-Atom">repeat_indices</span> <span class="o">=</span> <span class="p">[</span>

            <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span><span class="p">,</span> <span class="s s-Atom">v</span> <span class="s s-Atom">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="s s-Atom">metanodes</span><span class="p">)</span> <span class="s s-Atom">if</span> <span class="s s-Atom">v</span> <span class="o">==</span> <span class="s s-Atom">metanode</span><span class="p">]</span> <span class="s s-Atom">for</span> <span class="s s-Atom">metanode</span> <span class="s s-Atom">in</span> <span class="s s-Atom">nodes</span>

        <span class="p">]</span>

        <span class="s s-Atom">repeat_indices</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeat_indices</span> <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

        <span class="s s-Atom">simple_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">group</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeat_indices</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">group</span><span class="p">]</span>

        <span class="s s-Atom">inds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">repeat_indices:</span>

            <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">inds</span> <span class="s s-Atom">+=</span> <span class="s s-Atom">i</span>

            <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">inds</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="s s-Atom">inds</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="s s-Atom">for</span> <span class="s s-Atom">j</span> <span class="s s-Atom">in</span> <span class="s s-Atom">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:-</span><span class="mi">1</span><span class="p">]</span><span class="s s-Atom">:</span>

                    <span class="nf">if</span> <span class="p">(</span><span class="s s-Atom">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="s s-Atom">in</span> <span class="s s-Atom">simple_repeats</span> <span class="s s-Atom">and</span> <span class="s s-Atom">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="s s-Atom">in</span> <span class="s s-Atom">simple_repeats</span><span class="p">)</span> <span class="s s-Atom">and</span> <span class="o">not</span> <span class="p">(</span>

                        <span class="s s-Atom">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="s s-Atom">in</span> <span class="s s-Atom">i</span> <span class="s s-Atom">and</span> <span class="s s-Atom">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="s s-Atom">in</span> <span class="s s-Atom">i</span>

                    <span class="p">)</span><span class="s s-Atom">:</span>

                        <span class="s s-Atom">inds</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">j</span><span class="p">)</span>

        <span class="s s-Atom">inds</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="s s-Atom">inds</span><span class="p">)</span>

        <span class="s s-Atom">seconds</span> <span class="o">=</span> <span class="s s-Atom">inds</span><span class="p">[</span><span class="mi">1</span><span class="s s-Atom">:</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s s-Atom">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="s s-Atom">inds</span><span class="p">,</span> <span class="s s-Atom">seconds</span><span class="p">))</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">indices</span> <span class="s s-Atom">if</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="s s-Atom">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">]</span>

        <span class="s s-Atom">indices</span> <span class="o">=</span> <span class="nf">add_head_tail</span><span class="p">(</span><span class="s s-Atom">metapath</span><span class="p">,</span> <span class="s s-Atom">indices</span><span class="p">)</span>

    <span class="s s-Atom">segments</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">metapath</span><span class="p">[</span><span class="s s-Atom">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="s s-Atom">:</span> <span class="s s-Atom">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">indices</span><span class="p">]</span>

    <span class="s s-Atom">segments</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">i</span> <span class="s s-Atom">for</span> <span class="s s-Atom">i</span> <span class="s s-Atom">in</span> <span class="s s-Atom">segments</span> <span class="s s-Atom">if</span> <span class="s s-Atom">i</span><span class="p">]</span>

    <span class="s s-Atom">segments</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">metagraph</span><span class="p">.</span><span class="nf">get_metapath</span><span class="p">(</span><span class="s s-Atom">metaedges</span><span class="p">)</span> <span class="s s-Atom">for</span> <span class="s s-Atom">metaedges</span> <span class="s s-Atom">in</span> <span class="s s-Atom">segments</span><span class="p">]</span>

    <span class="s s-Atom">#</span> <span class="nn">eg</span><span class="p">:</span> <span class="nv">B</span> <span class="nv">CC</span> <span class="nv">ABA</span>

    <span class="s s-Atom">if</span> <span class="s s-Atom">category</span> <span class="o">==</span> <span class="s2">&quot;interior_complete_group&quot;</span><span class="s s-Atom">:</span>

        <span class="s s-Atom">segs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="s s-Atom">for</span> <span class="s s-Atom">i</span><span class="p">,</span> <span class="s s-Atom">v</span> <span class="s s-Atom">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="s s-Atom">segments</span><span class="p">[:-</span><span class="mi">1</span><span class="p">])</span><span class="s s-Atom">:</span>

            <span class="s s-Atom">if</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="nf">source</span><span class="p">()</span> <span class="o">==</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="nf">target</span><span class="p">()</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">edges</span> <span class="o">=</span> <span class="s s-Atom">v</span><span class="p">.</span><span class="s s-Atom">edges</span> <span class="o">+</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="s s-Atom">edges</span> <span class="o">+</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">].</span><span class="s s-Atom">edges</span>

                <span class="s s-Atom">segs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">metagraph</span><span class="p">.</span><span class="nf">get_metapath</span><span class="p">(</span><span class="s s-Atom">edges</span><span class="p">))</span>

            <span class="s s-Atom">elif</span> <span class="s s-Atom">v</span><span class="p">.</span><span class="nf">source</span><span class="p">()</span> <span class="o">==</span> <span class="s s-Atom">v</span><span class="p">.</span><span class="nf">target</span><span class="p">()</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">pass</span>

            <span class="s s-Atom">elif</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nf">source</span><span class="p">()</span> <span class="o">==</span> <span class="s s-Atom">segments</span><span class="p">[</span><span class="s s-Atom">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nf">target</span><span class="p">()</span><span class="s s-Atom">:</span>

                <span class="s s-Atom">pass</span>

            <span class="nn">else</span><span class="p">:</span>

                <span class="s s-Atom">segs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">v</span><span class="p">)</span>

        <span class="s s-Atom">segs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="s s-Atom">segments</span> <span class="o">=</span> <span class="s s-Atom">segs</span>

    <span class="s s-Atom">return</span> <span class="s s-Atom">segments</span>
</code></pre></div>

</details>
<h3 id="order_segments">order_segments</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">order_segments</span><span class="p">(</span>
    <span class="n">metagraph</span><span class="p">,</span>
    <span class="n">metapaths</span><span class="p">,</span>
    <span class="n">store_inverses</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>

<p>Gives the frequencies of metapath segments that occur when computing DWPC.</p>
<p>In DWPC computation, metapaths are split a number of times for simpler computation.
This function finds the frequencies that segments would be used when computing
DWPC for all given metapaths. For the targeted caching of the most frequently
used segments.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>metagraph</td>
<td>hetnetpy.hetnet.MetaGraph</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>metapaths</td>
<td>list</td>
<td>list of hetnetpy.hetnet.MetaPath objects</td>
<td>None</td>
</tr>
<tr>
<td>store_inverses</td>
<td>bool</td>
<td>Whether or not to include both forward and backward directions of segments.</td>
<td></td>
</tr>
<tr>
<td>For example, if False: [CbG, GbC] -&gt; [CbG, CbG], else no change.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>collections.Counter</td>
<td>Number of times each metapath segment appears when getting all segments.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">order_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span><span class="w"> </span><span class="n">metapaths</span><span class="p">,</span><span class="w"> </span><span class="n">store_inverses</span><span class="o">=</span><span class="kr">False</span><span class="p">)</span><span class="o">:</span><span class="w"></span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    Gives the frequencies of metapath segments that occur when computing DWPC.</span>

<span class="s">    In DWPC computation, metapaths are split a number of times for simpler computation.</span>

<span class="s">    This function finds the frequencies that segments would be used when computing</span>

<span class="s">    DWPC for all given metapaths. For the targeted caching of the most frequently</span>

<span class="s">    used segments.</span>

<span class="s">    Parameters</span>

<span class="s">    ----------</span>

<span class="s">    metagraph : hetnetpy.hetnet.MetaGraph</span>

<span class="s">    metapaths : list</span>

<span class="s">        list of hetnetpy.hetnet.MetaPath objects</span>

<span class="s">    store_inverses : bool</span>

<span class="s">        Whether or not to include both forward and backward directions of segments.</span>

<span class="s">        For example, if False: [CbG, GbC] -&gt; [CbG, CbG], else no change.</span>

<span class="s">    Returns</span>

<span class="s">    -------</span>

<span class="s">    collections.Counter</span>

<span class="s">        Number of times each metapath segment appears when getting all segments.</span>

<span class="s">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">all_segments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"></span>

<span class="w">        </span><span class="n">segment</span><span class="w"></span>

<span class="w">        </span><span class="n">for</span><span class="w"> </span><span class="n">metapath</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">metapaths</span><span class="w"></span>

<span class="w">        </span><span class="n">for</span><span class="w"> </span><span class="n">segment</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">get_all_segments</span><span class="p">(</span><span class="n">metagraph</span><span class="p">,</span><span class="w"> </span><span class="n">metapath</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="p">]</span><span class="w"></span>

<span class="w">    </span><span class="nf">if</span><span class="w"> </span><span class="kr">not</span><span class="w"> </span><span class="n">store_inverses</span><span class="o">:</span><span class="w"></span>

<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="n">Change</span><span class="w"> </span><span class="kr">all</span><span class="w"> </span><span class="n">instances</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">inverted</span><span class="w"> </span><span class="n">segments</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">first</span><span class="o">-</span><span class="n">seen</span><span class="w"> </span><span class="n">ordering</span><span class="w"></span>

<span class="w">        </span><span class="n">seen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">set</span><span class="p">()</span><span class="w"></span>

<span class="w">        </span><span class="n">aligned_segments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">()</span><span class="w"></span>

<span class="w">        </span><span class="n">for</span><span class="w"> </span><span class="n">segment</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">all_segments</span><span class="o">:</span><span class="w"></span>

<span class="w">            </span><span class="n">add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">segment</span><span class="p">.</span><span class="n">inverse</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="n">segment</span><span class="p">.</span><span class="n">inverse</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">seen</span><span class="w"> </span><span class="n">else</span><span class="w"> </span><span class="n">segment</span><span class="w"></span>

<span class="w">            </span><span class="n">aligned_segments</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">add</span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="n">seen</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">add</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">all_segments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aligned_segments</span><span class="w"></span>

<span class="w">    </span><span class="n">segment_counts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collections</span><span class="p">.</span><span class="kr">Counter</span><span class="p">(</span><span class="n">all_segments</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="n">segment_counts</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="remove_diag">remove_diag</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">remove_diag</span><span class="p">(</span>
    <span class="n">mat</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">&#39;&gt;</span>
<span class="p">)</span>
</code></pre></div>

<p>Set the main diagonal of a square matrix to zeros.</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">remove_diag</span><span class="ss">(</span><span class="nv">mat</span>, <span class="nv">dtype</span><span class="o">=</span><span class="nv">numpy</span>.<span class="nv">float64</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span><span class="s">Set the main diagonal of a square matrix to zeros.</span><span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">assert</span> <span class="nv">mat</span>.<span class="nv">shape</span>[<span class="mi">0</span>] <span class="o">==</span> <span class="nv">mat</span>.<span class="nv">shape</span>[<span class="mi">1</span>]  # <span class="nv">must</span> <span class="nv">be</span> <span class="nv">square</span>

    <span class="k">if</span> <span class="nv">sparse</span>.<span class="nv">issparse</span><span class="ss">(</span><span class="nv">mat</span><span class="ss">)</span>:

        <span class="k">return</span> <span class="nv">mat</span> <span class="o">-</span> <span class="nv">sparse</span>.<span class="nv">diags</span><span class="ss">(</span><span class="nv">mat</span>.<span class="nv">diagonal</span><span class="ss">()</span>, <span class="nv">dtype</span><span class="o">=</span><span class="nv">dtype</span><span class="ss">)</span>

    <span class="k">else</span>:

        <span class="k">return</span> <span class="nv">mat</span> <span class="o">-</span> <span class="nv">numpy</span>.<span class="nv">diag</span><span class="ss">(</span><span class="nv">mat</span>.<span class="nv">diagonal</span><span class="ss">())</span>
</code></pre></div>

</details>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../degree_group/" title="Degree Group" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Degree Group
              </span>
            </div>
          </a>
        
        
          <a href="../diffusion/" title="Diffusion" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Diffusion
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Powered by
        <a href="http://timothycrosley.github.io/portray">portray.</a>
        You too can
        <a href="http://timothycrosley.github.io/portray">
          portray</a>
        your Python project well using automatic documentation.
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../../assets/javascripts/workers/search.f8263e09.min.js", "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.4fc53ad4.min.js"></script>
      
    
  </body>
</html>